/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * ShopDjango API
 * API for ShopDjango project
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CatalogCategoriesListParams,
  CatalogDeliveriesListParams,
  CatalogImagesCreateBody,
  CatalogImagesListParams,
  CatalogManufacturersListParams,
  CatalogNotificationsPreferencesListParams,
  CatalogProductsListParams,
  CatalogSuppliersListParams,
  CatalogTagsListParams,
  Category,
  Manufacturer,
  ManufacturerCreate,
  ManufacturerList,
  ManufacturerUpdate,
  NotificationHistory,
  NotificationPreference,
  NotificationPreferenceUpdate,
  PaginatedProductDeliveryList,
  PaginatedProductListList,
  PaginatedSupplierList,
  PaginatedTagList,
  PatchedCategory,
  PatchedManufacturer,
  PatchedNotificationHistory,
  PatchedProductDelivery,
  PatchedProductDetail,
  PatchedProductImage,
  PatchedSupplier,
  PatchedTag,
  ProductCreate,
  ProductDelivery,
  ProductDetail,
  ProductImage,
  Supplier,
  Tag
} from '.././schemas';

import { shopInstance } from '../../../shop-mutator';
import type { ErrorType , BodyType } from '../../../shop-mutator';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * ViewSet for Category model with CRUD operations.
 */
export const catalogCategoriesList = (
    params?: CatalogCategoriesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Category[]>(
      {url: `/api/catalog/categories/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogCategoriesListQueryKey = (params?: CatalogCategoriesListParams,) => {
    return [`/api/catalog/categories/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogCategoriesListQueryOptions = <TData = Awaited<ReturnType<typeof catalogCategoriesList>>, TError = ErrorType<unknown>>(params?: CatalogCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogCategoriesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogCategoriesList>>> = ({ signal }) => catalogCategoriesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogCategoriesListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogCategoriesList>>>
export type CatalogCategoriesListQueryError = ErrorType<unknown>


export function useCatalogCategoriesList<TData = Awaited<ReturnType<typeof catalogCategoriesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogCategoriesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogCategoriesList>>,
          TError,
          Awaited<ReturnType<typeof catalogCategoriesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogCategoriesList<TData = Awaited<ReturnType<typeof catalogCategoriesList>>, TError = ErrorType<unknown>>(
 params?: CatalogCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogCategoriesList>>,
          TError,
          Awaited<ReturnType<typeof catalogCategoriesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogCategoriesList<TData = Awaited<ReturnType<typeof catalogCategoriesList>>, TError = ErrorType<unknown>>(
 params?: CatalogCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogCategoriesList<TData = Awaited<ReturnType<typeof catalogCategoriesList>>, TError = ErrorType<unknown>>(
 params?: CatalogCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogCategoriesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Category model with CRUD operations.
 */
export const catalogCategoriesCreate = (
    category: BodyType<NonReadonly<Category>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Category>(
      {url: `/api/catalog/categories/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: category, signal
    },
      );
    }
  


export const getCatalogCategoriesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesCreate>>, TError,{data: BodyType<NonReadonly<Category>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesCreate>>, TError,{data: BodyType<NonReadonly<Category>>}, TContext> => {

const mutationKey = ['catalogCategoriesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogCategoriesCreate>>, {data: BodyType<NonReadonly<Category>>}> = (props) => {
          const {data} = props ?? {};

          return  catalogCategoriesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogCategoriesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogCategoriesCreate>>>
    export type CatalogCategoriesCreateMutationBody = BodyType<NonReadonly<Category>>
    export type CatalogCategoriesCreateMutationError = ErrorType<unknown>

    export const useCatalogCategoriesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesCreate>>, TError,{data: BodyType<NonReadonly<Category>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogCategoriesCreate>>,
        TError,
        {data: BodyType<NonReadonly<Category>>},
        TContext
      > => {

      const mutationOptions = getCatalogCategoriesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Category model with CRUD operations.
 */
export const catalogCategoriesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Category>(
      {url: `/api/catalog/categories/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogCategoriesRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/categories/${id}/`] as const;
    }

    
export const getCatalogCategoriesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogCategoriesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>> = ({ signal }) => catalogCategoriesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogCategoriesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>>
export type CatalogCategoriesRetrieveQueryError = ErrorType<unknown>


export function useCatalogCategoriesRetrieve<TData = Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogCategoriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogCategoriesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogCategoriesRetrieve<TData = Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogCategoriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogCategoriesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogCategoriesRetrieve<TData = Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogCategoriesRetrieve<TData = Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogCategoriesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogCategoriesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Category model with CRUD operations.
 */
export const catalogCategoriesUpdate = (
    id: number,
    category: BodyType<NonReadonly<Category>>,
 ) => {
      
      
      return shopInstance<Category>(
      {url: `/api/catalog/categories/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: category
    },
      );
    }
  


export const getCatalogCategoriesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Category>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Category>>}, TContext> => {

const mutationKey = ['catalogCategoriesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogCategoriesUpdate>>, {id: number;data: BodyType<NonReadonly<Category>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogCategoriesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogCategoriesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogCategoriesUpdate>>>
    export type CatalogCategoriesUpdateMutationBody = BodyType<NonReadonly<Category>>
    export type CatalogCategoriesUpdateMutationError = ErrorType<unknown>

    export const useCatalogCategoriesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Category>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogCategoriesUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Category>>},
        TContext
      > => {

      const mutationOptions = getCatalogCategoriesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Category model with CRUD operations.
 */
export const catalogCategoriesPartialUpdate = (
    id: number,
    patchedCategory: BodyType<NonReadonly<PatchedCategory>>,
 ) => {
      
      
      return shopInstance<Category>(
      {url: `/api/catalog/categories/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCategory
    },
      );
    }
  


export const getCatalogCategoriesPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCategory>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCategory>>}, TContext> => {

const mutationKey = ['catalogCategoriesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogCategoriesPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedCategory>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogCategoriesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogCategoriesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogCategoriesPartialUpdate>>>
    export type CatalogCategoriesPartialUpdateMutationBody = BodyType<NonReadonly<PatchedCategory>>
    export type CatalogCategoriesPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogCategoriesPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCategory>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogCategoriesPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedCategory>>},
        TContext
      > => {

      const mutationOptions = getCatalogCategoriesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogCategoriesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/categories/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogCategoriesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogCategoriesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogCategoriesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogCategoriesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogCategoriesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogCategoriesDestroy>>>
    
    export type CatalogCategoriesDestroyMutationError = ErrorType<unknown>

    export const useCatalogCategoriesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogCategoriesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogCategoriesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogCategoriesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogDeliveriesList = (
    params?: CatalogDeliveriesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedProductDeliveryList>(
      {url: `/api/catalog/deliveries/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogDeliveriesListQueryKey = (params?: CatalogDeliveriesListParams,) => {
    return [`/api/catalog/deliveries/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogDeliveriesListQueryOptions = <TData = Awaited<ReturnType<typeof catalogDeliveriesList>>, TError = ErrorType<unknown>>(params?: CatalogDeliveriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogDeliveriesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogDeliveriesList>>> = ({ signal }) => catalogDeliveriesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogDeliveriesListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogDeliveriesList>>>
export type CatalogDeliveriesListQueryError = ErrorType<unknown>


export function useCatalogDeliveriesList<TData = Awaited<ReturnType<typeof catalogDeliveriesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogDeliveriesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogDeliveriesList>>,
          TError,
          Awaited<ReturnType<typeof catalogDeliveriesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogDeliveriesList<TData = Awaited<ReturnType<typeof catalogDeliveriesList>>, TError = ErrorType<unknown>>(
 params?: CatalogDeliveriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogDeliveriesList>>,
          TError,
          Awaited<ReturnType<typeof catalogDeliveriesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogDeliveriesList<TData = Awaited<ReturnType<typeof catalogDeliveriesList>>, TError = ErrorType<unknown>>(
 params?: CatalogDeliveriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogDeliveriesList<TData = Awaited<ReturnType<typeof catalogDeliveriesList>>, TError = ErrorType<unknown>>(
 params?: CatalogDeliveriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogDeliveriesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogDeliveriesCreate = (
    productDelivery: BodyType<NonReadonly<ProductDelivery>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductDelivery>(
      {url: `/api/catalog/deliveries/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productDelivery, signal
    },
      );
    }
  


export const getCatalogDeliveriesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesCreate>>, TError,{data: BodyType<NonReadonly<ProductDelivery>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesCreate>>, TError,{data: BodyType<NonReadonly<ProductDelivery>>}, TContext> => {

const mutationKey = ['catalogDeliveriesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogDeliveriesCreate>>, {data: BodyType<NonReadonly<ProductDelivery>>}> = (props) => {
          const {data} = props ?? {};

          return  catalogDeliveriesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogDeliveriesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogDeliveriesCreate>>>
    export type CatalogDeliveriesCreateMutationBody = BodyType<NonReadonly<ProductDelivery>>
    export type CatalogDeliveriesCreateMutationError = ErrorType<unknown>

    export const useCatalogDeliveriesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesCreate>>, TError,{data: BodyType<NonReadonly<ProductDelivery>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogDeliveriesCreate>>,
        TError,
        {data: BodyType<NonReadonly<ProductDelivery>>},
        TContext
      > => {

      const mutationOptions = getCatalogDeliveriesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogDeliveriesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductDelivery>(
      {url: `/api/catalog/deliveries/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogDeliveriesRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/deliveries/${id}/`] as const;
    }

    
export const getCatalogDeliveriesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogDeliveriesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>> = ({ signal }) => catalogDeliveriesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogDeliveriesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>>
export type CatalogDeliveriesRetrieveQueryError = ErrorType<unknown>


export function useCatalogDeliveriesRetrieve<TData = Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogDeliveriesRetrieve<TData = Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogDeliveriesRetrieve<TData = Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogDeliveriesRetrieve<TData = Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogDeliveriesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogDeliveriesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogDeliveriesUpdate = (
    id: number,
    productDelivery: BodyType<NonReadonly<ProductDelivery>>,
 ) => {
      
      
      return shopInstance<ProductDelivery>(
      {url: `/api/catalog/deliveries/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productDelivery
    },
      );
    }
  


export const getCatalogDeliveriesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductDelivery>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductDelivery>>}, TContext> => {

const mutationKey = ['catalogDeliveriesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogDeliveriesUpdate>>, {id: number;data: BodyType<NonReadonly<ProductDelivery>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogDeliveriesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogDeliveriesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogDeliveriesUpdate>>>
    export type CatalogDeliveriesUpdateMutationBody = BodyType<NonReadonly<ProductDelivery>>
    export type CatalogDeliveriesUpdateMutationError = ErrorType<unknown>

    export const useCatalogDeliveriesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductDelivery>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogDeliveriesUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<ProductDelivery>>},
        TContext
      > => {

      const mutationOptions = getCatalogDeliveriesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogDeliveriesPartialUpdate = (
    id: number,
    patchedProductDelivery: BodyType<NonReadonly<PatchedProductDelivery>>,
 ) => {
      
      
      return shopInstance<ProductDelivery>(
      {url: `/api/catalog/deliveries/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedProductDelivery
    },
      );
    }
  


export const getCatalogDeliveriesPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductDelivery>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductDelivery>>}, TContext> => {

const mutationKey = ['catalogDeliveriesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogDeliveriesPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedProductDelivery>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogDeliveriesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogDeliveriesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogDeliveriesPartialUpdate>>>
    export type CatalogDeliveriesPartialUpdateMutationBody = BodyType<NonReadonly<PatchedProductDelivery>>
    export type CatalogDeliveriesPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogDeliveriesPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductDelivery>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogDeliveriesPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedProductDelivery>>},
        TContext
      > => {

      const mutationOptions = getCatalogDeliveriesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogDeliveriesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/deliveries/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogDeliveriesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogDeliveriesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogDeliveriesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogDeliveriesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogDeliveriesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogDeliveriesDestroy>>>
    
    export type CatalogDeliveriesDestroyMutationError = ErrorType<unknown>

    export const useCatalogDeliveriesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogDeliveriesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogDeliveriesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogDeliveriesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for ProductImage model with CRUD operations.
 */
export const catalogImagesList = (
    params?: CatalogImagesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductImage[]>(
      {url: `/api/catalog/images/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogImagesListQueryKey = (params?: CatalogImagesListParams,) => {
    return [`/api/catalog/images/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogImagesListQueryOptions = <TData = Awaited<ReturnType<typeof catalogImagesList>>, TError = ErrorType<unknown>>(params?: CatalogImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogImagesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogImagesList>>> = ({ signal }) => catalogImagesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogImagesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogImagesListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogImagesList>>>
export type CatalogImagesListQueryError = ErrorType<unknown>


export function useCatalogImagesList<TData = Awaited<ReturnType<typeof catalogImagesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogImagesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogImagesList>>,
          TError,
          Awaited<ReturnType<typeof catalogImagesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogImagesList<TData = Awaited<ReturnType<typeof catalogImagesList>>, TError = ErrorType<unknown>>(
 params?: CatalogImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogImagesList>>,
          TError,
          Awaited<ReturnType<typeof catalogImagesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogImagesList<TData = Awaited<ReturnType<typeof catalogImagesList>>, TError = ErrorType<unknown>>(
 params?: CatalogImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogImagesList<TData = Awaited<ReturnType<typeof catalogImagesList>>, TError = ErrorType<unknown>>(
 params?: CatalogImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogImagesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new product image with file upload.
 */
export const catalogImagesCreate = (
    catalogImagesCreateBody: BodyType<CatalogImagesCreateBody>,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`image`, catalogImagesCreateBody.image)
formData.append(`product`, catalogImagesCreateBody.product.toString())
if(catalogImagesCreateBody.is_primary !== undefined) {
 formData.append(`is_primary`, catalogImagesCreateBody.is_primary.toString())
 }
if(catalogImagesCreateBody.sort_order !== undefined) {
 formData.append(`sort_order`, catalogImagesCreateBody.sort_order.toString())
 }

      return shopInstance<ProductImage>(
      {url: `/api/catalog/images/`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCatalogImagesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesCreate>>, TError,{data: BodyType<CatalogImagesCreateBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogImagesCreate>>, TError,{data: BodyType<CatalogImagesCreateBody>}, TContext> => {

const mutationKey = ['catalogImagesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogImagesCreate>>, {data: BodyType<CatalogImagesCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  catalogImagesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogImagesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogImagesCreate>>>
    export type CatalogImagesCreateMutationBody = BodyType<CatalogImagesCreateBody>
    export type CatalogImagesCreateMutationError = ErrorType<unknown>

    export const useCatalogImagesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesCreate>>, TError,{data: BodyType<CatalogImagesCreateBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogImagesCreate>>,
        TError,
        {data: BodyType<CatalogImagesCreateBody>},
        TContext
      > => {

      const mutationOptions = getCatalogImagesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for ProductImage model with CRUD operations.
 */
export const catalogImagesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductImage>(
      {url: `/api/catalog/images/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogImagesRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/images/${id}/`] as const;
    }

    
export const getCatalogImagesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogImagesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogImagesRetrieve>>> = ({ signal }) => catalogImagesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogImagesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogImagesRetrieve>>>
export type CatalogImagesRetrieveQueryError = ErrorType<unknown>


export function useCatalogImagesRetrieve<TData = Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogImagesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogImagesRetrieve<TData = Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogImagesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogImagesRetrieve<TData = Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogImagesRetrieve<TData = Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogImagesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogImagesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for ProductImage model with CRUD operations.
 */
export const catalogImagesUpdate = (
    id: number,
    productImage: BodyType<NonReadonly<ProductImage>>,
 ) => {
      
      
      return shopInstance<ProductImage>(
      {url: `/api/catalog/images/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productImage
    },
      );
    }
  


export const getCatalogImagesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductImage>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogImagesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductImage>>}, TContext> => {

const mutationKey = ['catalogImagesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogImagesUpdate>>, {id: number;data: BodyType<NonReadonly<ProductImage>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogImagesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogImagesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogImagesUpdate>>>
    export type CatalogImagesUpdateMutationBody = BodyType<NonReadonly<ProductImage>>
    export type CatalogImagesUpdateMutationError = ErrorType<unknown>

    export const useCatalogImagesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductImage>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogImagesUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<ProductImage>>},
        TContext
      > => {

      const mutationOptions = getCatalogImagesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for ProductImage model with CRUD operations.
 */
export const catalogImagesPartialUpdate = (
    id: number,
    patchedProductImage: BodyType<NonReadonly<PatchedProductImage>>,
 ) => {
      
      
      return shopInstance<ProductImage>(
      {url: `/api/catalog/images/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedProductImage
    },
      );
    }
  


export const getCatalogImagesPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductImage>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogImagesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductImage>>}, TContext> => {

const mutationKey = ['catalogImagesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogImagesPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedProductImage>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogImagesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogImagesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogImagesPartialUpdate>>>
    export type CatalogImagesPartialUpdateMutationBody = BodyType<NonReadonly<PatchedProductImage>>
    export type CatalogImagesPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogImagesPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductImage>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogImagesPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedProductImage>>},
        TContext
      > => {

      const mutationOptions = getCatalogImagesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogImagesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/images/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogImagesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogImagesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogImagesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogImagesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogImagesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogImagesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogImagesDestroy>>>
    
    export type CatalogImagesDestroyMutationError = ErrorType<unknown>

    export const useCatalogImagesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogImagesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogImagesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Set this image as primary for its product
 * @summary Set image as primary
 */
export const catalogImagesSetPrimaryCreate = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductImage>(
      {url: `/api/catalog/images/${id}/set_primary/`, method: 'POST', signal
    },
      );
    }
  


export const getCatalogImagesSetPrimaryCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesSetPrimaryCreate>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogImagesSetPrimaryCreate>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogImagesSetPrimaryCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogImagesSetPrimaryCreate>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogImagesSetPrimaryCreate(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogImagesSetPrimaryCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogImagesSetPrimaryCreate>>>
    
    export type CatalogImagesSetPrimaryCreateMutationError = ErrorType<unknown>

    /**
 * @summary Set image as primary
 */
export const useCatalogImagesSetPrimaryCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogImagesSetPrimaryCreate>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogImagesSetPrimaryCreate>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogImagesSetPrimaryCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogManufacturersList = (
    params?: CatalogManufacturersListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ManufacturerList[]>(
      {url: `/api/catalog/manufacturers/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogManufacturersListQueryKey = (params?: CatalogManufacturersListParams,) => {
    return [`/api/catalog/manufacturers/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogManufacturersListQueryOptions = <TData = Awaited<ReturnType<typeof catalogManufacturersList>>, TError = ErrorType<unknown>>(params?: CatalogManufacturersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogManufacturersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogManufacturersList>>> = ({ signal }) => catalogManufacturersList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogManufacturersListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogManufacturersList>>>
export type CatalogManufacturersListQueryError = ErrorType<unknown>


export function useCatalogManufacturersList<TData = Awaited<ReturnType<typeof catalogManufacturersList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogManufacturersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogManufacturersList>>,
          TError,
          Awaited<ReturnType<typeof catalogManufacturersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogManufacturersList<TData = Awaited<ReturnType<typeof catalogManufacturersList>>, TError = ErrorType<unknown>>(
 params?: CatalogManufacturersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogManufacturersList>>,
          TError,
          Awaited<ReturnType<typeof catalogManufacturersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogManufacturersList<TData = Awaited<ReturnType<typeof catalogManufacturersList>>, TError = ErrorType<unknown>>(
 params?: CatalogManufacturersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogManufacturersList<TData = Awaited<ReturnType<typeof catalogManufacturersList>>, TError = ErrorType<unknown>>(
 params?: CatalogManufacturersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogManufacturersListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogManufacturersCreate = (
    manufacturerCreate: BodyType<ManufacturerCreate>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ManufacturerCreate>(
      {url: `/api/catalog/manufacturers/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: manufacturerCreate, signal
    },
      );
    }
  


export const getCatalogManufacturersCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersCreate>>, TError,{data: BodyType<ManufacturerCreate>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersCreate>>, TError,{data: BodyType<ManufacturerCreate>}, TContext> => {

const mutationKey = ['catalogManufacturersCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogManufacturersCreate>>, {data: BodyType<ManufacturerCreate>}> = (props) => {
          const {data} = props ?? {};

          return  catalogManufacturersCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogManufacturersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogManufacturersCreate>>>
    export type CatalogManufacturersCreateMutationBody = BodyType<ManufacturerCreate>
    export type CatalogManufacturersCreateMutationError = ErrorType<unknown>

    export const useCatalogManufacturersCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersCreate>>, TError,{data: BodyType<ManufacturerCreate>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogManufacturersCreate>>,
        TError,
        {data: BodyType<ManufacturerCreate>},
        TContext
      > => {

      const mutationOptions = getCatalogManufacturersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogManufacturersRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Manufacturer>(
      {url: `/api/catalog/manufacturers/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogManufacturersRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/manufacturers/${id}/`] as const;
    }

    
export const getCatalogManufacturersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogManufacturersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>> = ({ signal }) => catalogManufacturersRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogManufacturersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>>
export type CatalogManufacturersRetrieveQueryError = ErrorType<unknown>


export function useCatalogManufacturersRetrieve<TData = Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogManufacturersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogManufacturersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogManufacturersRetrieve<TData = Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogManufacturersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogManufacturersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogManufacturersRetrieve<TData = Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogManufacturersRetrieve<TData = Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogManufacturersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogManufacturersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogManufacturersUpdate = (
    id: number,
    manufacturerUpdate: BodyType<ManufacturerUpdate>,
 ) => {
      
      
      return shopInstance<ManufacturerUpdate>(
      {url: `/api/catalog/manufacturers/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: manufacturerUpdate
    },
      );
    }
  


export const getCatalogManufacturersUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersUpdate>>, TError,{id: number;data: BodyType<ManufacturerUpdate>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersUpdate>>, TError,{id: number;data: BodyType<ManufacturerUpdate>}, TContext> => {

const mutationKey = ['catalogManufacturersUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogManufacturersUpdate>>, {id: number;data: BodyType<ManufacturerUpdate>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogManufacturersUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogManufacturersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogManufacturersUpdate>>>
    export type CatalogManufacturersUpdateMutationBody = BodyType<ManufacturerUpdate>
    export type CatalogManufacturersUpdateMutationError = ErrorType<unknown>

    export const useCatalogManufacturersUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersUpdate>>, TError,{id: number;data: BodyType<ManufacturerUpdate>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogManufacturersUpdate>>,
        TError,
        {id: number;data: BodyType<ManufacturerUpdate>},
        TContext
      > => {

      const mutationOptions = getCatalogManufacturersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogManufacturersPartialUpdate = (
    id: number,
    patchedManufacturer: BodyType<NonReadonly<PatchedManufacturer>>,
 ) => {
      
      
      return shopInstance<Manufacturer>(
      {url: `/api/catalog/manufacturers/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedManufacturer
    },
      );
    }
  


export const getCatalogManufacturersPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedManufacturer>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedManufacturer>>}, TContext> => {

const mutationKey = ['catalogManufacturersPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogManufacturersPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedManufacturer>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogManufacturersPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogManufacturersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogManufacturersPartialUpdate>>>
    export type CatalogManufacturersPartialUpdateMutationBody = BodyType<NonReadonly<PatchedManufacturer>>
    export type CatalogManufacturersPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogManufacturersPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedManufacturer>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogManufacturersPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedManufacturer>>},
        TContext
      > => {

      const mutationOptions = getCatalogManufacturersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogManufacturersDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/manufacturers/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogManufacturersDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogManufacturersDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogManufacturersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogManufacturersDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogManufacturersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogManufacturersDestroy>>>
    
    export type CatalogManufacturersDestroyMutationError = ErrorType<unknown>

    export const useCatalogManufacturersDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogManufacturersDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogManufacturersDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogManufacturersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for viewing notification history.
 */
export const catalogNotificationsHistoryCreate = (
    notificationHistory: BodyType<NonReadonly<NotificationHistory>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<NotificationHistory>(
      {url: `/api/catalog/notifications/history/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: notificationHistory, signal
    },
      );
    }
  


export const getCatalogNotificationsHistoryCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryCreate>>, TError,{data: BodyType<NonReadonly<NotificationHistory>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryCreate>>, TError,{data: BodyType<NonReadonly<NotificationHistory>>}, TContext> => {

const mutationKey = ['catalogNotificationsHistoryCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsHistoryCreate>>, {data: BodyType<NonReadonly<NotificationHistory>>}> = (props) => {
          const {data} = props ?? {};

          return  catalogNotificationsHistoryCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsHistoryCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsHistoryCreate>>>
    export type CatalogNotificationsHistoryCreateMutationBody = BodyType<NonReadonly<NotificationHistory>>
    export type CatalogNotificationsHistoryCreateMutationError = ErrorType<unknown>

    export const useCatalogNotificationsHistoryCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryCreate>>, TError,{data: BodyType<NonReadonly<NotificationHistory>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsHistoryCreate>>,
        TError,
        {data: BodyType<NonReadonly<NotificationHistory>>},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsHistoryCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for viewing notification history.
 */
export const catalogNotificationsHistoryUpdate = (
    id: string,
    notificationHistory: BodyType<NonReadonly<NotificationHistory>>,
 ) => {
      
      
      return shopInstance<NotificationHistory>(
      {url: `/api/catalog/notifications/history/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: notificationHistory
    },
      );
    }
  


export const getCatalogNotificationsHistoryUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryUpdate>>, TError,{id: string;data: BodyType<NonReadonly<NotificationHistory>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryUpdate>>, TError,{id: string;data: BodyType<NonReadonly<NotificationHistory>>}, TContext> => {

const mutationKey = ['catalogNotificationsHistoryUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsHistoryUpdate>>, {id: string;data: BodyType<NonReadonly<NotificationHistory>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogNotificationsHistoryUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsHistoryUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsHistoryUpdate>>>
    export type CatalogNotificationsHistoryUpdateMutationBody = BodyType<NonReadonly<NotificationHistory>>
    export type CatalogNotificationsHistoryUpdateMutationError = ErrorType<unknown>

    export const useCatalogNotificationsHistoryUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryUpdate>>, TError,{id: string;data: BodyType<NonReadonly<NotificationHistory>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsHistoryUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<NotificationHistory>>},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsHistoryUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for viewing notification history.
 */
export const catalogNotificationsHistoryPartialUpdate = (
    id: string,
    patchedNotificationHistory: BodyType<NonReadonly<PatchedNotificationHistory>>,
 ) => {
      
      
      return shopInstance<NotificationHistory>(
      {url: `/api/catalog/notifications/history/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedNotificationHistory
    },
      );
    }
  


export const getCatalogNotificationsHistoryPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedNotificationHistory>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedNotificationHistory>>}, TContext> => {

const mutationKey = ['catalogNotificationsHistoryPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsHistoryPartialUpdate>>, {id: string;data: BodyType<NonReadonly<PatchedNotificationHistory>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogNotificationsHistoryPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsHistoryPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsHistoryPartialUpdate>>>
    export type CatalogNotificationsHistoryPartialUpdateMutationBody = BodyType<NonReadonly<PatchedNotificationHistory>>
    export type CatalogNotificationsHistoryPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogNotificationsHistoryPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedNotificationHistory>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsHistoryPartialUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<PatchedNotificationHistory>>},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsHistoryPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogNotificationsHistoryDestroy = (
    id: string,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/notifications/history/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogNotificationsHistoryDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryDestroy>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['catalogNotificationsHistoryDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsHistoryDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  catalogNotificationsHistoryDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsHistoryDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsHistoryDestroy>>>
    
    export type CatalogNotificationsHistoryDestroyMutationError = ErrorType<unknown>

    export const useCatalogNotificationsHistoryDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsHistoryDestroy>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsHistoryDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsHistoryDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user notification preferences.
 */
export const catalogNotificationsPreferencesList = (
    params?: CatalogNotificationsPreferencesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<NotificationPreference[]>(
      {url: `/api/catalog/notifications/preferences/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogNotificationsPreferencesListQueryKey = (params?: CatalogNotificationsPreferencesListParams,) => {
    return [`/api/catalog/notifications/preferences/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogNotificationsPreferencesListQueryOptions = <TData = Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError = ErrorType<unknown>>(params?: CatalogNotificationsPreferencesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogNotificationsPreferencesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>> = ({ signal }) => catalogNotificationsPreferencesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogNotificationsPreferencesListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>>
export type CatalogNotificationsPreferencesListQueryError = ErrorType<unknown>


export function useCatalogNotificationsPreferencesList<TData = Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogNotificationsPreferencesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>,
          TError,
          Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogNotificationsPreferencesList<TData = Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError = ErrorType<unknown>>(
 params?: CatalogNotificationsPreferencesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>,
          TError,
          Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogNotificationsPreferencesList<TData = Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError = ErrorType<unknown>>(
 params?: CatalogNotificationsPreferencesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogNotificationsPreferencesList<TData = Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError = ErrorType<unknown>>(
 params?: CatalogNotificationsPreferencesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogNotificationsPreferencesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing user notification preferences.
 */
export const catalogNotificationsPreferencesCreate = (
    notificationPreference: BodyType<NonReadonly<NotificationPreference>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<NotificationPreference>(
      {url: `/api/catalog/notifications/preferences/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: notificationPreference, signal
    },
      );
    }
  


export const getCatalogNotificationsPreferencesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesCreate>>, TError,{data: BodyType<NonReadonly<NotificationPreference>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesCreate>>, TError,{data: BodyType<NonReadonly<NotificationPreference>>}, TContext> => {

const mutationKey = ['catalogNotificationsPreferencesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsPreferencesCreate>>, {data: BodyType<NonReadonly<NotificationPreference>>}> = (props) => {
          const {data} = props ?? {};

          return  catalogNotificationsPreferencesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsPreferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsPreferencesCreate>>>
    export type CatalogNotificationsPreferencesCreateMutationBody = BodyType<NonReadonly<NotificationPreference>>
    export type CatalogNotificationsPreferencesCreateMutationError = ErrorType<unknown>

    export const useCatalogNotificationsPreferencesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesCreate>>, TError,{data: BodyType<NonReadonly<NotificationPreference>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsPreferencesCreate>>,
        TError,
        {data: BodyType<NonReadonly<NotificationPreference>>},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsPreferencesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user notification preferences.
 */
export const catalogNotificationsPreferencesUpdate = (
    id: string,
    notificationPreferenceUpdate: BodyType<NotificationPreferenceUpdate>,
 ) => {
      
      
      return shopInstance<NotificationPreferenceUpdate>(
      {url: `/api/catalog/notifications/preferences/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: notificationPreferenceUpdate
    },
      );
    }
  


export const getCatalogNotificationsPreferencesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesUpdate>>, TError,{id: string;data: BodyType<NotificationPreferenceUpdate>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesUpdate>>, TError,{id: string;data: BodyType<NotificationPreferenceUpdate>}, TContext> => {

const mutationKey = ['catalogNotificationsPreferencesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsPreferencesUpdate>>, {id: string;data: BodyType<NotificationPreferenceUpdate>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogNotificationsPreferencesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsPreferencesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsPreferencesUpdate>>>
    export type CatalogNotificationsPreferencesUpdateMutationBody = BodyType<NotificationPreferenceUpdate>
    export type CatalogNotificationsPreferencesUpdateMutationError = ErrorType<unknown>

    export const useCatalogNotificationsPreferencesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesUpdate>>, TError,{id: string;data: BodyType<NotificationPreferenceUpdate>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsPreferencesUpdate>>,
        TError,
        {id: string;data: BodyType<NotificationPreferenceUpdate>},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsPreferencesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogNotificationsPreferencesDestroy = (
    id: string,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/notifications/preferences/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogNotificationsPreferencesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesDestroy>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['catalogNotificationsPreferencesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogNotificationsPreferencesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  catalogNotificationsPreferencesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogNotificationsPreferencesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogNotificationsPreferencesDestroy>>>
    
    export type CatalogNotificationsPreferencesDestroyMutationError = ErrorType<unknown>

    export const useCatalogNotificationsPreferencesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogNotificationsPreferencesDestroy>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogNotificationsPreferencesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCatalogNotificationsPreferencesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Product model with advanced CRUD operations.
 */
export const catalogProductsList = (
    params?: CatalogProductsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedProductListList>(
      {url: `/api/catalog/products/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogProductsListQueryKey = (params?: CatalogProductsListParams,) => {
    return [`/api/catalog/products/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogProductsListQueryOptions = <TData = Awaited<ReturnType<typeof catalogProductsList>>, TError = ErrorType<unknown>>(params?: CatalogProductsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogProductsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogProductsList>>> = ({ signal }) => catalogProductsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogProductsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogProductsListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogProductsList>>>
export type CatalogProductsListQueryError = ErrorType<unknown>


export function useCatalogProductsList<TData = Awaited<ReturnType<typeof catalogProductsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogProductsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogProductsList>>,
          TError,
          Awaited<ReturnType<typeof catalogProductsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogProductsList<TData = Awaited<ReturnType<typeof catalogProductsList>>, TError = ErrorType<unknown>>(
 params?: CatalogProductsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogProductsList>>,
          TError,
          Awaited<ReturnType<typeof catalogProductsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogProductsList<TData = Awaited<ReturnType<typeof catalogProductsList>>, TError = ErrorType<unknown>>(
 params?: CatalogProductsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogProductsList<TData = Awaited<ReturnType<typeof catalogProductsList>>, TError = ErrorType<unknown>>(
 params?: CatalogProductsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogProductsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Product model with advanced CRUD operations.
 */
export const catalogProductsCreate = (
    productCreate: BodyType<ProductCreate>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductCreate>(
      {url: `/api/catalog/products/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productCreate, signal
    },
      );
    }
  


export const getCatalogProductsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsCreate>>, TError,{data: BodyType<ProductCreate>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogProductsCreate>>, TError,{data: BodyType<ProductCreate>}, TContext> => {

const mutationKey = ['catalogProductsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogProductsCreate>>, {data: BodyType<ProductCreate>}> = (props) => {
          const {data} = props ?? {};

          return  catalogProductsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogProductsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogProductsCreate>>>
    export type CatalogProductsCreateMutationBody = BodyType<ProductCreate>
    export type CatalogProductsCreateMutationError = ErrorType<unknown>

    export const useCatalogProductsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsCreate>>, TError,{data: BodyType<ProductCreate>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogProductsCreate>>,
        TError,
        {data: BodyType<ProductCreate>},
        TContext
      > => {

      const mutationOptions = getCatalogProductsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Product model with advanced CRUD operations.
 */
export const catalogProductsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ProductDetail>(
      {url: `/api/catalog/products/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogProductsRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/products/${id}/`] as const;
    }

    
export const getCatalogProductsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogProductsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogProductsRetrieve>>> = ({ signal }) => catalogProductsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogProductsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogProductsRetrieve>>>
export type CatalogProductsRetrieveQueryError = ErrorType<unknown>


export function useCatalogProductsRetrieve<TData = Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogProductsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogProductsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogProductsRetrieve<TData = Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogProductsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogProductsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogProductsRetrieve<TData = Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogProductsRetrieve<TData = Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogProductsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogProductsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Product model with advanced CRUD operations.
 */
export const catalogProductsUpdate = (
    id: number,
    productDetail: BodyType<NonReadonly<ProductDetail>>,
 ) => {
      
      
      return shopInstance<ProductDetail>(
      {url: `/api/catalog/products/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productDetail
    },
      );
    }
  


export const getCatalogProductsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductDetail>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogProductsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductDetail>>}, TContext> => {

const mutationKey = ['catalogProductsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogProductsUpdate>>, {id: number;data: BodyType<NonReadonly<ProductDetail>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogProductsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogProductsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogProductsUpdate>>>
    export type CatalogProductsUpdateMutationBody = BodyType<NonReadonly<ProductDetail>>
    export type CatalogProductsUpdateMutationError = ErrorType<unknown>

    export const useCatalogProductsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ProductDetail>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogProductsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<ProductDetail>>},
        TContext
      > => {

      const mutationOptions = getCatalogProductsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Product model with advanced CRUD operations.
 */
export const catalogProductsPartialUpdate = (
    id: number,
    patchedProductDetail: BodyType<NonReadonly<PatchedProductDetail>>,
 ) => {
      
      
      return shopInstance<ProductDetail>(
      {url: `/api/catalog/products/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedProductDetail
    },
      );
    }
  


export const getCatalogProductsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductDetail>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogProductsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductDetail>>}, TContext> => {

const mutationKey = ['catalogProductsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogProductsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedProductDetail>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogProductsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogProductsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogProductsPartialUpdate>>>
    export type CatalogProductsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedProductDetail>>
    export type CatalogProductsPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogProductsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedProductDetail>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogProductsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedProductDetail>>},
        TContext
      > => {

      const mutationOptions = getCatalogProductsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Soft delete: set is_visible=False instead of actually deleting.
 */
export const catalogProductsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/products/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogProductsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogProductsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogProductsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogProductsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogProductsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogProductsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogProductsDestroy>>>
    
    export type CatalogProductsDestroyMutationError = ErrorType<unknown>

    export const useCatalogProductsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogProductsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogProductsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogProductsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogSuppliersList = (
    params?: CatalogSuppliersListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedSupplierList>(
      {url: `/api/catalog/suppliers/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogSuppliersListQueryKey = (params?: CatalogSuppliersListParams,) => {
    return [`/api/catalog/suppliers/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogSuppliersListQueryOptions = <TData = Awaited<ReturnType<typeof catalogSuppliersList>>, TError = ErrorType<unknown>>(params?: CatalogSuppliersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogSuppliersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogSuppliersList>>> = ({ signal }) => catalogSuppliersList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogSuppliersListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogSuppliersList>>>
export type CatalogSuppliersListQueryError = ErrorType<unknown>


export function useCatalogSuppliersList<TData = Awaited<ReturnType<typeof catalogSuppliersList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogSuppliersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogSuppliersList>>,
          TError,
          Awaited<ReturnType<typeof catalogSuppliersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogSuppliersList<TData = Awaited<ReturnType<typeof catalogSuppliersList>>, TError = ErrorType<unknown>>(
 params?: CatalogSuppliersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogSuppliersList>>,
          TError,
          Awaited<ReturnType<typeof catalogSuppliersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogSuppliersList<TData = Awaited<ReturnType<typeof catalogSuppliersList>>, TError = ErrorType<unknown>>(
 params?: CatalogSuppliersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogSuppliersList<TData = Awaited<ReturnType<typeof catalogSuppliersList>>, TError = ErrorType<unknown>>(
 params?: CatalogSuppliersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogSuppliersListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogSuppliersCreate = (
    supplier: BodyType<NonReadonly<Supplier>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Supplier>(
      {url: `/api/catalog/suppliers/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: supplier, signal
    },
      );
    }
  


export const getCatalogSuppliersCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersCreate>>, TError,{data: BodyType<NonReadonly<Supplier>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersCreate>>, TError,{data: BodyType<NonReadonly<Supplier>>}, TContext> => {

const mutationKey = ['catalogSuppliersCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogSuppliersCreate>>, {data: BodyType<NonReadonly<Supplier>>}> = (props) => {
          const {data} = props ?? {};

          return  catalogSuppliersCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogSuppliersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogSuppliersCreate>>>
    export type CatalogSuppliersCreateMutationBody = BodyType<NonReadonly<Supplier>>
    export type CatalogSuppliersCreateMutationError = ErrorType<unknown>

    export const useCatalogSuppliersCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersCreate>>, TError,{data: BodyType<NonReadonly<Supplier>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogSuppliersCreate>>,
        TError,
        {data: BodyType<NonReadonly<Supplier>>},
        TContext
      > => {

      const mutationOptions = getCatalogSuppliersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogSuppliersRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Supplier>(
      {url: `/api/catalog/suppliers/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogSuppliersRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/suppliers/${id}/`] as const;
    }

    
export const getCatalogSuppliersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogSuppliersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>> = ({ signal }) => catalogSuppliersRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogSuppliersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>>
export type CatalogSuppliersRetrieveQueryError = ErrorType<unknown>


export function useCatalogSuppliersRetrieve<TData = Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogSuppliersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogSuppliersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogSuppliersRetrieve<TData = Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogSuppliersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogSuppliersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogSuppliersRetrieve<TData = Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogSuppliersRetrieve<TData = Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogSuppliersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogSuppliersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogSuppliersUpdate = (
    id: number,
    supplier: BodyType<NonReadonly<Supplier>>,
 ) => {
      
      
      return shopInstance<Supplier>(
      {url: `/api/catalog/suppliers/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: supplier
    },
      );
    }
  


export const getCatalogSuppliersUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Supplier>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Supplier>>}, TContext> => {

const mutationKey = ['catalogSuppliersUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogSuppliersUpdate>>, {id: number;data: BodyType<NonReadonly<Supplier>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogSuppliersUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogSuppliersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogSuppliersUpdate>>>
    export type CatalogSuppliersUpdateMutationBody = BodyType<NonReadonly<Supplier>>
    export type CatalogSuppliersUpdateMutationError = ErrorType<unknown>

    export const useCatalogSuppliersUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Supplier>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogSuppliersUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Supplier>>},
        TContext
      > => {

      const mutationOptions = getCatalogSuppliersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const catalogSuppliersPartialUpdate = (
    id: number,
    patchedSupplier: BodyType<NonReadonly<PatchedSupplier>>,
 ) => {
      
      
      return shopInstance<Supplier>(
      {url: `/api/catalog/suppliers/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSupplier
    },
      );
    }
  


export const getCatalogSuppliersPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedSupplier>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedSupplier>>}, TContext> => {

const mutationKey = ['catalogSuppliersPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogSuppliersPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedSupplier>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogSuppliersPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogSuppliersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogSuppliersPartialUpdate>>>
    export type CatalogSuppliersPartialUpdateMutationBody = BodyType<NonReadonly<PatchedSupplier>>
    export type CatalogSuppliersPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogSuppliersPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedSupplier>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogSuppliersPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedSupplier>>},
        TContext
      > => {

      const mutationOptions = getCatalogSuppliersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogSuppliersDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/suppliers/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogSuppliersDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogSuppliersDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogSuppliersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogSuppliersDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogSuppliersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogSuppliersDestroy>>>
    
    export type CatalogSuppliersDestroyMutationError = ErrorType<unknown>

    export const useCatalogSuppliersDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogSuppliersDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogSuppliersDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogSuppliersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Tag model with CRUD operations.
 */
export const catalogTagsList = (
    params?: CatalogTagsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedTagList>(
      {url: `/api/catalog/tags/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCatalogTagsListQueryKey = (params?: CatalogTagsListParams,) => {
    return [`/api/catalog/tags/`, ...(params ? [params]: [])] as const;
    }

    
export const getCatalogTagsListQueryOptions = <TData = Awaited<ReturnType<typeof catalogTagsList>>, TError = ErrorType<unknown>>(params?: CatalogTagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogTagsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogTagsList>>> = ({ signal }) => catalogTagsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogTagsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogTagsListQueryResult = NonNullable<Awaited<ReturnType<typeof catalogTagsList>>>
export type CatalogTagsListQueryError = ErrorType<unknown>


export function useCatalogTagsList<TData = Awaited<ReturnType<typeof catalogTagsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CatalogTagsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogTagsList>>,
          TError,
          Awaited<ReturnType<typeof catalogTagsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogTagsList<TData = Awaited<ReturnType<typeof catalogTagsList>>, TError = ErrorType<unknown>>(
 params?: CatalogTagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogTagsList>>,
          TError,
          Awaited<ReturnType<typeof catalogTagsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogTagsList<TData = Awaited<ReturnType<typeof catalogTagsList>>, TError = ErrorType<unknown>>(
 params?: CatalogTagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogTagsList<TData = Awaited<ReturnType<typeof catalogTagsList>>, TError = ErrorType<unknown>>(
 params?: CatalogTagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogTagsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Tag model with CRUD operations.
 */
export const catalogTagsCreate = (
    tag: BodyType<NonReadonly<Tag>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Tag>(
      {url: `/api/catalog/tags/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tag, signal
    },
      );
    }
  


export const getCatalogTagsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsCreate>>, TError,{data: BodyType<NonReadonly<Tag>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogTagsCreate>>, TError,{data: BodyType<NonReadonly<Tag>>}, TContext> => {

const mutationKey = ['catalogTagsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogTagsCreate>>, {data: BodyType<NonReadonly<Tag>>}> = (props) => {
          const {data} = props ?? {};

          return  catalogTagsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogTagsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogTagsCreate>>>
    export type CatalogTagsCreateMutationBody = BodyType<NonReadonly<Tag>>
    export type CatalogTagsCreateMutationError = ErrorType<unknown>

    export const useCatalogTagsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsCreate>>, TError,{data: BodyType<NonReadonly<Tag>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogTagsCreate>>,
        TError,
        {data: BodyType<NonReadonly<Tag>>},
        TContext
      > => {

      const mutationOptions = getCatalogTagsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Tag model with CRUD operations.
 */
export const catalogTagsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Tag>(
      {url: `/api/catalog/tags/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCatalogTagsRetrieveQueryKey = (id: number,) => {
    return [`/api/catalog/tags/${id}/`] as const;
    }

    
export const getCatalogTagsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCatalogTagsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof catalogTagsRetrieve>>> = ({ signal }) => catalogTagsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogTagsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof catalogTagsRetrieve>>>
export type CatalogTagsRetrieveQueryError = ErrorType<unknown>


export function useCatalogTagsRetrieve<TData = Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogTagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogTagsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogTagsRetrieve<TData = Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogTagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof catalogTagsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCatalogTagsRetrieve<TData = Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCatalogTagsRetrieve<TData = Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof catalogTagsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCatalogTagsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Tag model with CRUD operations.
 */
export const catalogTagsUpdate = (
    id: number,
    tag: BodyType<NonReadonly<Tag>>,
 ) => {
      
      
      return shopInstance<Tag>(
      {url: `/api/catalog/tags/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: tag
    },
      );
    }
  


export const getCatalogTagsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Tag>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogTagsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Tag>>}, TContext> => {

const mutationKey = ['catalogTagsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogTagsUpdate>>, {id: number;data: BodyType<NonReadonly<Tag>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogTagsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogTagsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogTagsUpdate>>>
    export type CatalogTagsUpdateMutationBody = BodyType<NonReadonly<Tag>>
    export type CatalogTagsUpdateMutationError = ErrorType<unknown>

    export const useCatalogTagsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Tag>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogTagsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Tag>>},
        TContext
      > => {

      const mutationOptions = getCatalogTagsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Tag model with CRUD operations.
 */
export const catalogTagsPartialUpdate = (
    id: number,
    patchedTag: BodyType<NonReadonly<PatchedTag>>,
 ) => {
      
      
      return shopInstance<Tag>(
      {url: `/api/catalog/tags/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedTag
    },
      );
    }
  


export const getCatalogTagsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedTag>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogTagsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedTag>>}, TContext> => {

const mutationKey = ['catalogTagsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogTagsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedTag>>}> = (props) => {
          const {id,data} = props ?? {};

          return  catalogTagsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogTagsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof catalogTagsPartialUpdate>>>
    export type CatalogTagsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedTag>>
    export type CatalogTagsPartialUpdateMutationError = ErrorType<unknown>

    export const useCatalogTagsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedTag>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogTagsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedTag>>},
        TContext
      > => {

      const mutationOptions = getCatalogTagsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const catalogTagsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/catalog/tags/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCatalogTagsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof catalogTagsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['catalogTagsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof catalogTagsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  catalogTagsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CatalogTagsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof catalogTagsDestroy>>>
    
    export type CatalogTagsDestroyMutationError = ErrorType<unknown>

    export const useCatalogTagsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof catalogTagsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof catalogTagsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCatalogTagsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    