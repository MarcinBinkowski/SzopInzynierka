/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * ShopDjango API
 * API for ShopDjango project
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Cart,
  CartItem,
  CartItemCreate,
  CheckoutCartsListParams,
  CheckoutConfirmPaymentIntentCreate400,
  CheckoutConfirmPaymentIntentCreate500,
  CheckoutCouponRedemptionsListParams,
  CheckoutCouponsListParams,
  CheckoutCouriersListParams,
  CheckoutDashboardRetrieveParams,
  CheckoutInvoiceTemplatesListParams,
  CheckoutInvoicesDownloadByOrderRetrieveParams,
  CheckoutInvoicesListParams,
  CheckoutItemsListParams,
  CheckoutOrderNotesListParams,
  CheckoutOrdersExportCsvRetrieveParams,
  CheckoutOrdersListParams,
  CheckoutPaymentsListParams,
  CheckoutSessionResponse,
  CheckoutShipmentsListParams,
  CheckoutShippingMethodsListParams,
  ConfirmPayment,
  Coupon,
  CouponRedemption,
  CouponValidateRequest,
  CouponValidationResponse,
  Courier,
  CreateCheckoutSession,
  DashboardStats,
  Invoice,
  InvoiceNotFound,
  InvoiceTemplate,
  Order,
  OrderDetail,
  OrderProcessingNote,
  PaginatedCartListList,
  PaginatedCouponList,
  PaginatedCouponRedemptionList,
  PaginatedCourierList,
  PaginatedOrderProcessingNoteList,
  PaginatedOrdersListResponseList,
  PaginatedPaymentList,
  PaginatedShipmentList,
  PatchedCart,
  PatchedCartItem,
  PatchedCoupon,
  PatchedCouponRedemption,
  PatchedCourier,
  PatchedInvoice,
  PatchedInvoiceTemplate,
  PatchedOrder,
  PatchedOrderProcessingNote,
  PatchedPayment,
  PatchedShipment,
  PatchedShippingMethod,
  Payment,
  PaymentConfirmationResponse,
  Shipment,
  ShippingMethod,
  TemplateValidationError,
  TemplateValidationResponse
} from '.././schemas';

import { shopInstance } from '../../../shop-mutator';
import type { ErrorType , BodyType } from '../../../shop-mutator';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * ViewSet for Cart model with CRUD operations.
 */
export const checkoutCartsList = (
    params?: CheckoutCartsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedCartListList>(
      {url: `/api/checkout/carts/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutCartsListQueryKey = (params?: CheckoutCartsListParams,) => {
    return [`/api/checkout/carts/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutCartsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCartsList>>, TError = ErrorType<unknown>>(params?: CheckoutCartsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCartsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCartsList>>> = ({ signal }) => checkoutCartsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCartsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsList>>>
export type CheckoutCartsListQueryError = ErrorType<unknown>


export function useCheckoutCartsList<TData = Awaited<ReturnType<typeof checkoutCartsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutCartsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCartsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCartsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCartsList<TData = Awaited<ReturnType<typeof checkoutCartsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCartsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCartsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCartsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCartsList<TData = Awaited<ReturnType<typeof checkoutCartsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCartsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCartsList<TData = Awaited<ReturnType<typeof checkoutCartsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCartsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCartsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Cart model with CRUD operations.
 */
export const checkoutCartsCreate = (
    cart: BodyType<NonReadonly<Cart>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Cart>(
      {url: `/api/checkout/carts/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cart, signal
    },
      );
    }
  


export const getCheckoutCartsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsCreate>>, TError,{data: BodyType<NonReadonly<Cart>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsCreate>>, TError,{data: BodyType<NonReadonly<Cart>>}, TContext> => {

const mutationKey = ['checkoutCartsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCartsCreate>>, {data: BodyType<NonReadonly<Cart>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCartsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCartsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsCreate>>>
    export type CheckoutCartsCreateMutationBody = BodyType<NonReadonly<Cart>>
    export type CheckoutCartsCreateMutationError = ErrorType<unknown>

    export const useCheckoutCartsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsCreate>>, TError,{data: BodyType<NonReadonly<Cart>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCartsCreate>>,
        TError,
        {data: BodyType<NonReadonly<Cart>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCartsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Cart model with CRUD operations.
 */
export const checkoutCartsRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Cart>(
      {url: `/api/checkout/carts/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutCartsRetrieveQueryKey = (id: string,) => {
    return [`/api/checkout/carts/${id}/`] as const;
    }

    
export const getCheckoutCartsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCartsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCartsRetrieve>>> = ({ signal }) => checkoutCartsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCartsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsRetrieve>>>
export type CheckoutCartsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutCartsRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCartsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCartsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCartsRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCartsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCartsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCartsRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCartsRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCartsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for Cart model with CRUD operations.
 */
export const checkoutCartsUpdate = (
    id: string,
    cart: BodyType<NonReadonly<Cart>>,
 ) => {
      
      
      return shopInstance<Cart>(
      {url: `/api/checkout/carts/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: cart
    },
      );
    }
  


export const getCheckoutCartsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsUpdate>>, TError,{id: string;data: BodyType<NonReadonly<Cart>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsUpdate>>, TError,{id: string;data: BodyType<NonReadonly<Cart>>}, TContext> => {

const mutationKey = ['checkoutCartsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCartsUpdate>>, {id: string;data: BodyType<NonReadonly<Cart>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCartsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCartsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsUpdate>>>
    export type CheckoutCartsUpdateMutationBody = BodyType<NonReadonly<Cart>>
    export type CheckoutCartsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCartsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsUpdate>>, TError,{id: string;data: BodyType<NonReadonly<Cart>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCartsUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<Cart>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCartsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for Cart model with CRUD operations.
 */
export const checkoutCartsPartialUpdate = (
    id: string,
    patchedCart: BodyType<NonReadonly<PatchedCart>>,
 ) => {
      
      
      return shopInstance<Cart>(
      {url: `/api/checkout/carts/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCart
    },
      );
    }
  


export const getCheckoutCartsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedCart>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedCart>>}, TContext> => {

const mutationKey = ['checkoutCartsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCartsPartialUpdate>>, {id: string;data: BodyType<NonReadonly<PatchedCart>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCartsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCartsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsPartialUpdate>>>
    export type CheckoutCartsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedCart>>
    export type CheckoutCartsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCartsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedCart>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCartsPartialUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<PatchedCart>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCartsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutCartsDestroy = (
    id: string,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/carts/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutCartsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsDestroy>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['checkoutCartsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCartsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  checkoutCartsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCartsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsDestroy>>>
    
    export type CheckoutCartsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutCartsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCartsDestroy>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCartsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCheckoutCartsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get current user's active cart.
 */
export const checkoutCartsCurrentRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Cart>(
      {url: `/api/checkout/carts/current/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutCartsCurrentRetrieveQueryKey = () => {
    return [`/api/checkout/carts/current/`] as const;
    }

    
export const getCheckoutCartsCurrentRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCartsCurrentRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>> = ({ signal }) => checkoutCartsCurrentRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCartsCurrentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>>
export type CheckoutCartsCurrentRetrieveQueryError = ErrorType<unknown>


export function useCheckoutCartsCurrentRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCartsCurrentRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCartsCurrentRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCartsCurrentRetrieve<TData = Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCartsCurrentRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCartsCurrentRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Confirm PaymentIntent and create order after successful PaymentSheet payment.
 */
export const checkoutConfirmPaymentIntentCreate = (
    confirmPayment: BodyType<ConfirmPayment>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaymentConfirmationResponse>(
      {url: `/api/checkout/confirm_payment_intent/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: confirmPayment, signal
    },
      );
    }
  


export const getCheckoutConfirmPaymentIntentCreateMutationOptions = <TError = ErrorType<CheckoutConfirmPaymentIntentCreate400 | CheckoutConfirmPaymentIntentCreate500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutConfirmPaymentIntentCreate>>, TError,{data: BodyType<ConfirmPayment>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutConfirmPaymentIntentCreate>>, TError,{data: BodyType<ConfirmPayment>}, TContext> => {

const mutationKey = ['checkoutConfirmPaymentIntentCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutConfirmPaymentIntentCreate>>, {data: BodyType<ConfirmPayment>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutConfirmPaymentIntentCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutConfirmPaymentIntentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutConfirmPaymentIntentCreate>>>
    export type CheckoutConfirmPaymentIntentCreateMutationBody = BodyType<ConfirmPayment>
    export type CheckoutConfirmPaymentIntentCreateMutationError = ErrorType<CheckoutConfirmPaymentIntentCreate400 | CheckoutConfirmPaymentIntentCreate500>

    export const useCheckoutConfirmPaymentIntentCreate = <TError = ErrorType<CheckoutConfirmPaymentIntentCreate400 | CheckoutConfirmPaymentIntentCreate500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutConfirmPaymentIntentCreate>>, TError,{data: BodyType<ConfirmPayment>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutConfirmPaymentIntentCreate>>,
        TError,
        {data: BodyType<ConfirmPayment>},
        TContext
      > => {

      const mutationOptions = getCheckoutConfirmPaymentIntentCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouponRedemptionsList = (
    params?: CheckoutCouponRedemptionsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedCouponRedemptionList>(
      {url: `/api/checkout/coupon-redemptions/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutCouponRedemptionsListQueryKey = (params?: CheckoutCouponRedemptionsListParams,) => {
    return [`/api/checkout/coupon-redemptions/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutCouponRedemptionsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError = ErrorType<unknown>>(params?: CheckoutCouponRedemptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCouponRedemptionsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>> = ({ signal }) => checkoutCouponRedemptionsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCouponRedemptionsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>>
export type CheckoutCouponRedemptionsListQueryError = ErrorType<unknown>


export function useCheckoutCouponRedemptionsList<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutCouponRedemptionsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponRedemptionsList<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouponRedemptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponRedemptionsList<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouponRedemptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCouponRedemptionsList<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouponRedemptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCouponRedemptionsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouponRedemptionsCreate = (
    couponRedemption: BodyType<NonReadonly<CouponRedemption>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CouponRedemption>(
      {url: `/api/checkout/coupon-redemptions/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: couponRedemption, signal
    },
      );
    }
  


export const getCheckoutCouponRedemptionsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsCreate>>, TError,{data: BodyType<NonReadonly<CouponRedemption>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsCreate>>, TError,{data: BodyType<NonReadonly<CouponRedemption>>}, TContext> => {

const mutationKey = ['checkoutCouponRedemptionsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponRedemptionsCreate>>, {data: BodyType<NonReadonly<CouponRedemption>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCouponRedemptionsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponRedemptionsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponRedemptionsCreate>>>
    export type CheckoutCouponRedemptionsCreateMutationBody = BodyType<NonReadonly<CouponRedemption>>
    export type CheckoutCouponRedemptionsCreateMutationError = ErrorType<unknown>

    export const useCheckoutCouponRedemptionsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsCreate>>, TError,{data: BodyType<NonReadonly<CouponRedemption>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponRedemptionsCreate>>,
        TError,
        {data: BodyType<NonReadonly<CouponRedemption>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponRedemptionsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouponRedemptionsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CouponRedemption>(
      {url: `/api/checkout/coupon-redemptions/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutCouponRedemptionsRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/coupon-redemptions/${id}/`] as const;
    }

    
export const getCheckoutCouponRedemptionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCouponRedemptionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>> = ({ signal }) => checkoutCouponRedemptionsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCouponRedemptionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>>
export type CheckoutCouponRedemptionsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutCouponRedemptionsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponRedemptionsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponRedemptionsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCouponRedemptionsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCouponRedemptionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouponRedemptionsUpdate = (
    id: number,
    couponRedemption: BodyType<NonReadonly<CouponRedemption>>,
 ) => {
      
      
      return shopInstance<CouponRedemption>(
      {url: `/api/checkout/coupon-redemptions/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: couponRedemption
    },
      );
    }
  


export const getCheckoutCouponRedemptionsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<CouponRedemption>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<CouponRedemption>>}, TContext> => {

const mutationKey = ['checkoutCouponRedemptionsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponRedemptionsUpdate>>, {id: number;data: BodyType<NonReadonly<CouponRedemption>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCouponRedemptionsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponRedemptionsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponRedemptionsUpdate>>>
    export type CheckoutCouponRedemptionsUpdateMutationBody = BodyType<NonReadonly<CouponRedemption>>
    export type CheckoutCouponRedemptionsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCouponRedemptionsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<CouponRedemption>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponRedemptionsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<CouponRedemption>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponRedemptionsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouponRedemptionsPartialUpdate = (
    id: number,
    patchedCouponRedemption: BodyType<NonReadonly<PatchedCouponRedemption>>,
 ) => {
      
      
      return shopInstance<CouponRedemption>(
      {url: `/api/checkout/coupon-redemptions/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCouponRedemption
    },
      );
    }
  


export const getCheckoutCouponRedemptionsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCouponRedemption>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCouponRedemption>>}, TContext> => {

const mutationKey = ['checkoutCouponRedemptionsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponRedemptionsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedCouponRedemption>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCouponRedemptionsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponRedemptionsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponRedemptionsPartialUpdate>>>
    export type CheckoutCouponRedemptionsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedCouponRedemption>>
    export type CheckoutCouponRedemptionsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCouponRedemptionsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCouponRedemption>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponRedemptionsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedCouponRedemption>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponRedemptionsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutCouponRedemptionsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/coupon-redemptions/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutCouponRedemptionsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutCouponRedemptionsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponRedemptionsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutCouponRedemptionsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponRedemptionsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponRedemptionsDestroy>>>
    
    export type CheckoutCouponRedemptionsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutCouponRedemptionsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponRedemptionsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponRedemptionsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponRedemptionsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Full CRUD ViewSet for coupon management.
 */
export const checkoutCouponsList = (
    params?: CheckoutCouponsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedCouponList>(
      {url: `/api/checkout/coupons/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutCouponsListQueryKey = (params?: CheckoutCouponsListParams,) => {
    return [`/api/checkout/coupons/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutCouponsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCouponsList>>, TError = ErrorType<unknown>>(params?: CheckoutCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCouponsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCouponsList>>> = ({ signal }) => checkoutCouponsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCouponsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsList>>>
export type CheckoutCouponsListQueryError = ErrorType<unknown>


export function useCheckoutCouponsList<TData = Awaited<ReturnType<typeof checkoutCouponsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutCouponsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponsList<TData = Awaited<ReturnType<typeof checkoutCouponsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponsList<TData = Awaited<ReturnType<typeof checkoutCouponsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCouponsList<TData = Awaited<ReturnType<typeof checkoutCouponsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCouponsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Full CRUD ViewSet for coupon management.
 */
export const checkoutCouponsCreate = (
    coupon: BodyType<NonReadonly<Coupon>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Coupon>(
      {url: `/api/checkout/coupons/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: coupon, signal
    },
      );
    }
  


export const getCheckoutCouponsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsCreate>>, TError,{data: BodyType<NonReadonly<Coupon>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsCreate>>, TError,{data: BodyType<NonReadonly<Coupon>>}, TContext> => {

const mutationKey = ['checkoutCouponsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponsCreate>>, {data: BodyType<NonReadonly<Coupon>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCouponsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsCreate>>>
    export type CheckoutCouponsCreateMutationBody = BodyType<NonReadonly<Coupon>>
    export type CheckoutCouponsCreateMutationError = ErrorType<unknown>

    export const useCheckoutCouponsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsCreate>>, TError,{data: BodyType<NonReadonly<Coupon>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponsCreate>>,
        TError,
        {data: BodyType<NonReadonly<Coupon>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Full CRUD ViewSet for coupon management.
 */
export const checkoutCouponsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Coupon>(
      {url: `/api/checkout/coupons/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutCouponsRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/coupons/${id}/`] as const;
    }

    
export const getCheckoutCouponsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCouponsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>> = ({ signal }) => checkoutCouponsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCouponsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>>
export type CheckoutCouponsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutCouponsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouponsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouponsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouponsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCouponsRetrieve<TData = Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouponsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCouponsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Full CRUD ViewSet for coupon management.
 */
export const checkoutCouponsUpdate = (
    id: number,
    coupon: BodyType<NonReadonly<Coupon>>,
 ) => {
      
      
      return shopInstance<Coupon>(
      {url: `/api/checkout/coupons/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: coupon
    },
      );
    }
  


export const getCheckoutCouponsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Coupon>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Coupon>>}, TContext> => {

const mutationKey = ['checkoutCouponsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponsUpdate>>, {id: number;data: BodyType<NonReadonly<Coupon>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCouponsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsUpdate>>>
    export type CheckoutCouponsUpdateMutationBody = BodyType<NonReadonly<Coupon>>
    export type CheckoutCouponsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCouponsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Coupon>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Coupon>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Full CRUD ViewSet for coupon management.
 */
export const checkoutCouponsPartialUpdate = (
    id: number,
    patchedCoupon: BodyType<NonReadonly<PatchedCoupon>>,
 ) => {
      
      
      return shopInstance<Coupon>(
      {url: `/api/checkout/coupons/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCoupon
    },
      );
    }
  


export const getCheckoutCouponsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCoupon>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCoupon>>}, TContext> => {

const mutationKey = ['checkoutCouponsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedCoupon>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCouponsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsPartialUpdate>>>
    export type CheckoutCouponsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedCoupon>>
    export type CheckoutCouponsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCouponsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCoupon>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedCoupon>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutCouponsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/coupons/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutCouponsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutCouponsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutCouponsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsDestroy>>>
    
    export type CheckoutCouponsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutCouponsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Remove the currently applied coupon from the user's active cart
 * @summary Remove coupon from cart
 */
export const checkoutCouponsRemoveCreate = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Coupon>(
      {url: `/api/checkout/coupons/remove/`, method: 'POST', signal
    },
      );
    }
  


export const getCheckoutCouponsRemoveCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsRemoveCreate>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsRemoveCreate>>, TError,void, TContext> => {

const mutationKey = ['checkoutCouponsRemoveCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponsRemoveCreate>>, void> = () => {
          

          return  checkoutCouponsRemoveCreate()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponsRemoveCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsRemoveCreate>>>
    
    export type CheckoutCouponsRemoveCreateMutationError = ErrorType<unknown>

    /**
 * @summary Remove coupon from cart
 */
export const useCheckoutCouponsRemoveCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsRemoveCreate>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponsRemoveCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCheckoutCouponsRemoveCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Validate and apply coupon to cart
 * @summary Validate coupon
 */
export const checkoutCouponsValidateCreate = (
    couponValidateRequest: BodyType<CouponValidateRequest>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CouponValidationResponse>(
      {url: `/api/checkout/coupons/validate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: couponValidateRequest, signal
    },
      );
    }
  


export const getCheckoutCouponsValidateCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsValidateCreate>>, TError,{data: BodyType<CouponValidateRequest>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsValidateCreate>>, TError,{data: BodyType<CouponValidateRequest>}, TContext> => {

const mutationKey = ['checkoutCouponsValidateCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouponsValidateCreate>>, {data: BodyType<CouponValidateRequest>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCouponsValidateCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouponsValidateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouponsValidateCreate>>>
    export type CheckoutCouponsValidateCreateMutationBody = BodyType<CouponValidateRequest>
    export type CheckoutCouponsValidateCreateMutationError = ErrorType<unknown>

    /**
 * @summary Validate coupon
 */
export const useCheckoutCouponsValidateCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouponsValidateCreate>>, TError,{data: BodyType<CouponValidateRequest>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouponsValidateCreate>>,
        TError,
        {data: BodyType<CouponValidateRequest>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouponsValidateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouriersList = (
    params?: CheckoutCouriersListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedCourierList>(
      {url: `/api/checkout/couriers/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutCouriersListQueryKey = (params?: CheckoutCouriersListParams,) => {
    return [`/api/checkout/couriers/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutCouriersListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCouriersList>>, TError = ErrorType<unknown>>(params?: CheckoutCouriersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCouriersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCouriersList>>> = ({ signal }) => checkoutCouriersList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCouriersListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCouriersList>>>
export type CheckoutCouriersListQueryError = ErrorType<unknown>


export function useCheckoutCouriersList<TData = Awaited<ReturnType<typeof checkoutCouriersList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutCouriersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouriersList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouriersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouriersList<TData = Awaited<ReturnType<typeof checkoutCouriersList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouriersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouriersList>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouriersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouriersList<TData = Awaited<ReturnType<typeof checkoutCouriersList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouriersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCouriersList<TData = Awaited<ReturnType<typeof checkoutCouriersList>>, TError = ErrorType<unknown>>(
 params?: CheckoutCouriersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCouriersListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouriersCreate = (
    courier: BodyType<NonReadonly<Courier>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Courier>(
      {url: `/api/checkout/couriers/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: courier, signal
    },
      );
    }
  


export const getCheckoutCouriersCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersCreate>>, TError,{data: BodyType<NonReadonly<Courier>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersCreate>>, TError,{data: BodyType<NonReadonly<Courier>>}, TContext> => {

const mutationKey = ['checkoutCouriersCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouriersCreate>>, {data: BodyType<NonReadonly<Courier>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCouriersCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouriersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouriersCreate>>>
    export type CheckoutCouriersCreateMutationBody = BodyType<NonReadonly<Courier>>
    export type CheckoutCouriersCreateMutationError = ErrorType<unknown>

    export const useCheckoutCouriersCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersCreate>>, TError,{data: BodyType<NonReadonly<Courier>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouriersCreate>>,
        TError,
        {data: BodyType<NonReadonly<Courier>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouriersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouriersRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Courier>(
      {url: `/api/checkout/couriers/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutCouriersRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/couriers/${id}/`] as const;
    }

    
export const getCheckoutCouriersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutCouriersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>> = ({ signal }) => checkoutCouriersRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutCouriersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>>
export type CheckoutCouriersRetrieveQueryError = ErrorType<unknown>


export function useCheckoutCouriersRetrieve<TData = Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouriersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouriersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouriersRetrieve<TData = Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutCouriersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutCouriersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutCouriersRetrieve<TData = Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutCouriersRetrieve<TData = Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutCouriersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutCouriersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouriersUpdate = (
    id: number,
    courier: BodyType<NonReadonly<Courier>>,
 ) => {
      
      
      return shopInstance<Courier>(
      {url: `/api/checkout/couriers/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: courier
    },
      );
    }
  


export const getCheckoutCouriersUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Courier>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Courier>>}, TContext> => {

const mutationKey = ['checkoutCouriersUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouriersUpdate>>, {id: number;data: BodyType<NonReadonly<Courier>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCouriersUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouriersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouriersUpdate>>>
    export type CheckoutCouriersUpdateMutationBody = BodyType<NonReadonly<Courier>>
    export type CheckoutCouriersUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCouriersUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Courier>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouriersUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Courier>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouriersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutCouriersPartialUpdate = (
    id: number,
    patchedCourier: BodyType<NonReadonly<PatchedCourier>>,
 ) => {
      
      
      return shopInstance<Courier>(
      {url: `/api/checkout/couriers/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCourier
    },
      );
    }
  


export const getCheckoutCouriersPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCourier>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCourier>>}, TContext> => {

const mutationKey = ['checkoutCouriersPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouriersPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedCourier>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutCouriersPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouriersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouriersPartialUpdate>>>
    export type CheckoutCouriersPartialUpdateMutationBody = BodyType<NonReadonly<PatchedCourier>>
    export type CheckoutCouriersPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutCouriersPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedCourier>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouriersPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedCourier>>},
        TContext
      > => {

      const mutationOptions = getCheckoutCouriersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutCouriersDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/couriers/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutCouriersDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutCouriersDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCouriersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutCouriersDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCouriersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCouriersDestroy>>>
    
    export type CheckoutCouriersDestroyMutationError = ErrorType<unknown>

    export const useCheckoutCouriersDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCouriersDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCouriersDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutCouriersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Create a Stripe Checkout session for a cart.
 */
export const checkoutCreateCheckoutSessionCreate = (
    createCheckoutSession: BodyType<CreateCheckoutSession>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CheckoutSessionResponse>(
      {url: `/api/checkout/create_checkout_session/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCheckoutSession, signal
    },
      );
    }
  


export const getCheckoutCreateCheckoutSessionCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCreateCheckoutSessionCreate>>, TError,{data: BodyType<CreateCheckoutSession>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCreateCheckoutSessionCreate>>, TError,{data: BodyType<CreateCheckoutSession>}, TContext> => {

const mutationKey = ['checkoutCreateCheckoutSessionCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCreateCheckoutSessionCreate>>, {data: BodyType<CreateCheckoutSession>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCreateCheckoutSessionCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCreateCheckoutSessionCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCreateCheckoutSessionCreate>>>
    export type CheckoutCreateCheckoutSessionCreateMutationBody = BodyType<CreateCheckoutSession>
    export type CheckoutCreateCheckoutSessionCreateMutationError = ErrorType<unknown>

    export const useCheckoutCreateCheckoutSessionCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCreateCheckoutSessionCreate>>, TError,{data: BodyType<CreateCheckoutSession>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCreateCheckoutSessionCreate>>,
        TError,
        {data: BodyType<CreateCheckoutSession>},
        TContext
      > => {

      const mutationOptions = getCheckoutCreateCheckoutSessionCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get dashboard statistics for the given period (24h, 7d, 30d, lifetime)
 * @summary Dashboard analytics
 */
export const checkoutDashboardRetrieve = (
    params?: CheckoutDashboardRetrieveParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<DashboardStats>(
      {url: `/api/checkout/dashboard/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutDashboardRetrieveQueryKey = (params?: CheckoutDashboardRetrieveParams,) => {
    return [`/api/checkout/dashboard/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutDashboardRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError = ErrorType<unknown>>(params?: CheckoutDashboardRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutDashboardRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>> = ({ signal }) => checkoutDashboardRetrieve(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutDashboardRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>>
export type CheckoutDashboardRetrieveQueryError = ErrorType<unknown>


export function useCheckoutDashboardRetrieve<TData = Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutDashboardRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutDashboardRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutDashboardRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutDashboardRetrieve<TData = Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError = ErrorType<unknown>>(
 params?: CheckoutDashboardRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutDashboardRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutDashboardRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutDashboardRetrieve<TData = Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError = ErrorType<unknown>>(
 params?: CheckoutDashboardRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Dashboard analytics
 */

export function useCheckoutDashboardRetrieve<TData = Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError = ErrorType<unknown>>(
 params?: CheckoutDashboardRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutDashboardRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutDashboardRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing invoice templates.
 */
export const checkoutInvoiceTemplatesList = (
    params?: CheckoutInvoiceTemplatesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<InvoiceTemplate[]>(
      {url: `/api/checkout/invoice-templates/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutInvoiceTemplatesListQueryKey = (params?: CheckoutInvoiceTemplatesListParams,) => {
    return [`/api/checkout/invoice-templates/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutInvoiceTemplatesListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError = ErrorType<unknown>>(params?: CheckoutInvoiceTemplatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutInvoiceTemplatesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>> = ({ signal }) => checkoutInvoiceTemplatesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutInvoiceTemplatesListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>>
export type CheckoutInvoiceTemplatesListQueryError = ErrorType<unknown>


export function useCheckoutInvoiceTemplatesList<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutInvoiceTemplatesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoiceTemplatesList<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutInvoiceTemplatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoiceTemplatesList<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutInvoiceTemplatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutInvoiceTemplatesList<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutInvoiceTemplatesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutInvoiceTemplatesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing invoice templates.
 */
export const checkoutInvoiceTemplatesCreate = (
    invoiceTemplate: BodyType<NonReadonly<InvoiceTemplate>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<InvoiceTemplate>(
      {url: `/api/checkout/invoice-templates/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoiceTemplate, signal
    },
      );
    }
  


export const getCheckoutInvoiceTemplatesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesCreate>>, TError,{data: BodyType<NonReadonly<InvoiceTemplate>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesCreate>>, TError,{data: BodyType<NonReadonly<InvoiceTemplate>>}, TContext> => {

const mutationKey = ['checkoutInvoiceTemplatesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesCreate>>, {data: BodyType<NonReadonly<InvoiceTemplate>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutInvoiceTemplatesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoiceTemplatesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesCreate>>>
    export type CheckoutInvoiceTemplatesCreateMutationBody = BodyType<NonReadonly<InvoiceTemplate>>
    export type CheckoutInvoiceTemplatesCreateMutationError = ErrorType<unknown>

    export const useCheckoutInvoiceTemplatesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesCreate>>, TError,{data: BodyType<NonReadonly<InvoiceTemplate>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoiceTemplatesCreate>>,
        TError,
        {data: BodyType<NonReadonly<InvoiceTemplate>>},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoiceTemplatesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing invoice templates.
 */
export const checkoutInvoiceTemplatesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<InvoiceTemplate>(
      {url: `/api/checkout/invoice-templates/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutInvoiceTemplatesRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/invoice-templates/${id}/`] as const;
    }

    
export const getCheckoutInvoiceTemplatesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutInvoiceTemplatesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>> = ({ signal }) => checkoutInvoiceTemplatesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutInvoiceTemplatesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>>
export type CheckoutInvoiceTemplatesRetrieveQueryError = ErrorType<unknown>


export function useCheckoutInvoiceTemplatesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoiceTemplatesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoiceTemplatesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutInvoiceTemplatesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutInvoiceTemplatesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing invoice templates.
 */
export const checkoutInvoiceTemplatesUpdate = (
    id: number,
    invoiceTemplate: BodyType<NonReadonly<InvoiceTemplate>>,
 ) => {
      
      
      return shopInstance<InvoiceTemplate>(
      {url: `/api/checkout/invoice-templates/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: invoiceTemplate
    },
      );
    }
  


export const getCheckoutInvoiceTemplatesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<InvoiceTemplate>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<InvoiceTemplate>>}, TContext> => {

const mutationKey = ['checkoutInvoiceTemplatesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesUpdate>>, {id: number;data: BodyType<NonReadonly<InvoiceTemplate>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutInvoiceTemplatesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoiceTemplatesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesUpdate>>>
    export type CheckoutInvoiceTemplatesUpdateMutationBody = BodyType<NonReadonly<InvoiceTemplate>>
    export type CheckoutInvoiceTemplatesUpdateMutationError = ErrorType<unknown>

    export const useCheckoutInvoiceTemplatesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<InvoiceTemplate>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoiceTemplatesUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<InvoiceTemplate>>},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoiceTemplatesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing invoice templates.
 */
export const checkoutInvoiceTemplatesPartialUpdate = (
    id: number,
    patchedInvoiceTemplate: BodyType<NonReadonly<PatchedInvoiceTemplate>>,
 ) => {
      
      
      return shopInstance<InvoiceTemplate>(
      {url: `/api/checkout/invoice-templates/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedInvoiceTemplate
    },
      );
    }
  


export const getCheckoutInvoiceTemplatesPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedInvoiceTemplate>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedInvoiceTemplate>>}, TContext> => {

const mutationKey = ['checkoutInvoiceTemplatesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedInvoiceTemplate>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutInvoiceTemplatesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoiceTemplatesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesPartialUpdate>>>
    export type CheckoutInvoiceTemplatesPartialUpdateMutationBody = BodyType<NonReadonly<PatchedInvoiceTemplate>>
    export type CheckoutInvoiceTemplatesPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutInvoiceTemplatesPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedInvoiceTemplate>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoiceTemplatesPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedInvoiceTemplate>>},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoiceTemplatesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutInvoiceTemplatesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/invoice-templates/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutInvoiceTemplatesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutInvoiceTemplatesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutInvoiceTemplatesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoiceTemplatesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesDestroy>>>
    
    export type CheckoutInvoiceTemplatesDestroyMutationError = ErrorType<unknown>

    export const useCheckoutInvoiceTemplatesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoiceTemplatesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoiceTemplatesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Validates Jinja2 template syntax and checks for forbidden properties
 * @summary Validate template syntax and security
 */
export const checkoutInvoiceTemplatesVariablesRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<TemplateValidationResponse>(
      {url: `/api/checkout/invoice-templates/variables/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutInvoiceTemplatesVariablesRetrieveQueryKey = () => {
    return [`/api/checkout/invoice-templates/variables/`] as const;
    }

    
export const getCheckoutInvoiceTemplatesVariablesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError = ErrorType<TemplateValidationError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutInvoiceTemplatesVariablesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>> = ({ signal }) => checkoutInvoiceTemplatesVariablesRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutInvoiceTemplatesVariablesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>>
export type CheckoutInvoiceTemplatesVariablesRetrieveQueryError = ErrorType<TemplateValidationError>


export function useCheckoutInvoiceTemplatesVariablesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError = ErrorType<TemplateValidationError>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoiceTemplatesVariablesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError = ErrorType<TemplateValidationError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoiceTemplatesVariablesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError = ErrorType<TemplateValidationError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Validate template syntax and security
 */

export function useCheckoutInvoiceTemplatesVariablesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError = ErrorType<TemplateValidationError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoiceTemplatesVariablesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutInvoiceTemplatesVariablesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing invoices.
 */
export const checkoutInvoicesList = (
    params?: CheckoutInvoicesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Invoice[]>(
      {url: `/api/checkout/invoices/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutInvoicesListQueryKey = (params?: CheckoutInvoicesListParams,) => {
    return [`/api/checkout/invoices/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutInvoicesListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutInvoicesList>>, TError = ErrorType<unknown>>(params?: CheckoutInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutInvoicesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutInvoicesList>>> = ({ signal }) => checkoutInvoicesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutInvoicesListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesList>>>
export type CheckoutInvoicesListQueryError = ErrorType<unknown>


export function useCheckoutInvoicesList<TData = Awaited<ReturnType<typeof checkoutInvoicesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutInvoicesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoicesList>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoicesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoicesList<TData = Awaited<ReturnType<typeof checkoutInvoicesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoicesList>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoicesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoicesList<TData = Awaited<ReturnType<typeof checkoutInvoicesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutInvoicesList<TData = Awaited<ReturnType<typeof checkoutInvoicesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutInvoicesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing invoices.
 */
export const checkoutInvoicesCreate = (
    invoice: BodyType<NonReadonly<Invoice>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Invoice>(
      {url: `/api/checkout/invoices/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoice, signal
    },
      );
    }
  


export const getCheckoutInvoicesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesCreate>>, TError,{data: BodyType<NonReadonly<Invoice>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesCreate>>, TError,{data: BodyType<NonReadonly<Invoice>>}, TContext> => {

const mutationKey = ['checkoutInvoicesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoicesCreate>>, {data: BodyType<NonReadonly<Invoice>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutInvoicesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoicesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesCreate>>>
    export type CheckoutInvoicesCreateMutationBody = BodyType<NonReadonly<Invoice>>
    export type CheckoutInvoicesCreateMutationError = ErrorType<unknown>

    export const useCheckoutInvoicesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesCreate>>, TError,{data: BodyType<NonReadonly<Invoice>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoicesCreate>>,
        TError,
        {data: BodyType<NonReadonly<Invoice>>},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoicesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing invoices.
 */
export const checkoutInvoicesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Invoice>(
      {url: `/api/checkout/invoices/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutInvoicesRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/invoices/${id}/`] as const;
    }

    
export const getCheckoutInvoicesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutInvoicesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>> = ({ signal }) => checkoutInvoicesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutInvoicesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>>
export type CheckoutInvoicesRetrieveQueryError = ErrorType<unknown>


export function useCheckoutInvoicesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoicesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoicesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutInvoicesRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutInvoicesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing invoices.
 */
export const checkoutInvoicesUpdate = (
    id: number,
    invoice: BodyType<NonReadonly<Invoice>>,
 ) => {
      
      
      return shopInstance<Invoice>(
      {url: `/api/checkout/invoices/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: invoice
    },
      );
    }
  


export const getCheckoutInvoicesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Invoice>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Invoice>>}, TContext> => {

const mutationKey = ['checkoutInvoicesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoicesUpdate>>, {id: number;data: BodyType<NonReadonly<Invoice>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutInvoicesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoicesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesUpdate>>>
    export type CheckoutInvoicesUpdateMutationBody = BodyType<NonReadonly<Invoice>>
    export type CheckoutInvoicesUpdateMutationError = ErrorType<unknown>

    export const useCheckoutInvoicesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Invoice>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoicesUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Invoice>>},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoicesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing invoices.
 */
export const checkoutInvoicesPartialUpdate = (
    id: number,
    patchedInvoice: BodyType<NonReadonly<PatchedInvoice>>,
 ) => {
      
      
      return shopInstance<Invoice>(
      {url: `/api/checkout/invoices/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedInvoice
    },
      );
    }
  


export const getCheckoutInvoicesPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedInvoice>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedInvoice>>}, TContext> => {

const mutationKey = ['checkoutInvoicesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoicesPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedInvoice>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutInvoicesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoicesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesPartialUpdate>>>
    export type CheckoutInvoicesPartialUpdateMutationBody = BodyType<NonReadonly<PatchedInvoice>>
    export type CheckoutInvoicesPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutInvoicesPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedInvoice>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoicesPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedInvoice>>},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoicesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutInvoicesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/invoices/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutInvoicesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutInvoicesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutInvoicesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutInvoicesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutInvoicesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesDestroy>>>
    
    export type CheckoutInvoicesDestroyMutationError = ErrorType<unknown>

    export const useCheckoutInvoicesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutInvoicesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutInvoicesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutInvoicesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Downloads the PDF invoice for a specific order
 * @summary Download invoice PDF by order
 */
export const checkoutInvoicesDownloadByOrderRetrieve = (
    params: CheckoutInvoicesDownloadByOrderRetrieveParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Blob>(
      {url: `/api/checkout/invoices/download_by_order/`, method: 'GET',
        params,
        responseType: 'blob', signal
    },
      );
    }
  

export const getCheckoutInvoicesDownloadByOrderRetrieveQueryKey = (params: CheckoutInvoicesDownloadByOrderRetrieveParams,) => {
    return [`/api/checkout/invoices/download_by_order/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutInvoicesDownloadByOrderRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError = ErrorType<InvoiceNotFound>>(params: CheckoutInvoicesDownloadByOrderRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutInvoicesDownloadByOrderRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>> = ({ signal }) => checkoutInvoicesDownloadByOrderRetrieve(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutInvoicesDownloadByOrderRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>>
export type CheckoutInvoicesDownloadByOrderRetrieveQueryError = ErrorType<InvoiceNotFound>


export function useCheckoutInvoicesDownloadByOrderRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError = ErrorType<InvoiceNotFound>>(
 params: CheckoutInvoicesDownloadByOrderRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoicesDownloadByOrderRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError = ErrorType<InvoiceNotFound>>(
 params: CheckoutInvoicesDownloadByOrderRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutInvoicesDownloadByOrderRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError = ErrorType<InvoiceNotFound>>(
 params: CheckoutInvoicesDownloadByOrderRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download invoice PDF by order
 */

export function useCheckoutInvoicesDownloadByOrderRetrieve<TData = Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError = ErrorType<InvoiceNotFound>>(
 params: CheckoutInvoicesDownloadByOrderRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutInvoicesDownloadByOrderRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutInvoicesDownloadByOrderRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for CartItem model with CRUD operations.
 */
export const checkoutItemsList = (
    params?: CheckoutItemsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CartItem[]>(
      {url: `/api/checkout/items/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutItemsListQueryKey = (params?: CheckoutItemsListParams,) => {
    return [`/api/checkout/items/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutItemsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutItemsList>>, TError = ErrorType<unknown>>(params?: CheckoutItemsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutItemsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutItemsList>>> = ({ signal }) => checkoutItemsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutItemsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsList>>>
export type CheckoutItemsListQueryError = ErrorType<unknown>


export function useCheckoutItemsList<TData = Awaited<ReturnType<typeof checkoutItemsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutItemsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutItemsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutItemsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutItemsList<TData = Awaited<ReturnType<typeof checkoutItemsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutItemsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutItemsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutItemsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutItemsList<TData = Awaited<ReturnType<typeof checkoutItemsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutItemsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutItemsList<TData = Awaited<ReturnType<typeof checkoutItemsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutItemsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutItemsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for CartItem model with CRUD operations.
 */
export const checkoutItemsCreate = (
    cartItemCreate: BodyType<CartItemCreate>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CartItemCreate>(
      {url: `/api/checkout/items/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cartItemCreate, signal
    },
      );
    }
  


export const getCheckoutItemsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsCreate>>, TError,{data: BodyType<CartItemCreate>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsCreate>>, TError,{data: BodyType<CartItemCreate>}, TContext> => {

const mutationKey = ['checkoutItemsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsCreate>>, {data: BodyType<CartItemCreate>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutItemsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsCreate>>>
    export type CheckoutItemsCreateMutationBody = BodyType<CartItemCreate>
    export type CheckoutItemsCreateMutationError = ErrorType<unknown>

    export const useCheckoutItemsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsCreate>>, TError,{data: BodyType<CartItemCreate>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsCreate>>,
        TError,
        {data: BodyType<CartItemCreate>},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for CartItem model with CRUD operations.
 */
export const checkoutItemsRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CartItem>(
      {url: `/api/checkout/items/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutItemsRetrieveQueryKey = (id: string,) => {
    return [`/api/checkout/items/${id}/`] as const;
    }

    
export const getCheckoutItemsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutItemsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutItemsRetrieve>>> = ({ signal }) => checkoutItemsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutItemsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsRetrieve>>>
export type CheckoutItemsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutItemsRetrieve<TData = Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutItemsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutItemsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutItemsRetrieve<TData = Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutItemsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutItemsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutItemsRetrieve<TData = Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutItemsRetrieve<TData = Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutItemsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutItemsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for CartItem model with CRUD operations.
 */
export const checkoutItemsUpdate = (
    id: string,
    cartItem: BodyType<NonReadonly<CartItem>>,
 ) => {
      
      
      return shopInstance<CartItem>(
      {url: `/api/checkout/items/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: cartItem
    },
      );
    }
  


export const getCheckoutItemsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsUpdate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsUpdate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext> => {

const mutationKey = ['checkoutItemsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsUpdate>>, {id: string;data: BodyType<NonReadonly<CartItem>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutItemsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsUpdate>>>
    export type CheckoutItemsUpdateMutationBody = BodyType<NonReadonly<CartItem>>
    export type CheckoutItemsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutItemsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsUpdate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<CartItem>>},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for CartItem model with CRUD operations.
 */
export const checkoutItemsPartialUpdate = (
    id: string,
    patchedCartItem: BodyType<NonReadonly<PatchedCartItem>>,
 ) => {
      
      
      return shopInstance<CartItem>(
      {url: `/api/checkout/items/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCartItem
    },
      );
    }
  


export const getCheckoutItemsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedCartItem>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedCartItem>>}, TContext> => {

const mutationKey = ['checkoutItemsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsPartialUpdate>>, {id: string;data: BodyType<NonReadonly<PatchedCartItem>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutItemsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsPartialUpdate>>>
    export type CheckoutItemsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedCartItem>>
    export type CheckoutItemsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutItemsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedCartItem>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsPartialUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<PatchedCartItem>>},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutItemsDestroy = (
    id: string,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/items/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutItemsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsDestroy>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['checkoutItemsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  checkoutItemsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsDestroy>>>
    
    export type CheckoutItemsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutItemsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsDestroy>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Decrease item quantity.
 */
export const checkoutItemsDecreaseQuantityCreate = (
    id: string,
    cartItem: BodyType<NonReadonly<CartItem>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CartItem>(
      {url: `/api/checkout/items/${id}/decrease_quantity/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cartItem, signal
    },
      );
    }
  


export const getCheckoutItemsDecreaseQuantityCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsDecreaseQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsDecreaseQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext> => {

const mutationKey = ['checkoutItemsDecreaseQuantityCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsDecreaseQuantityCreate>>, {id: string;data: BodyType<NonReadonly<CartItem>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutItemsDecreaseQuantityCreate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsDecreaseQuantityCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsDecreaseQuantityCreate>>>
    export type CheckoutItemsDecreaseQuantityCreateMutationBody = BodyType<NonReadonly<CartItem>>
    export type CheckoutItemsDecreaseQuantityCreateMutationError = ErrorType<unknown>

    export const useCheckoutItemsDecreaseQuantityCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsDecreaseQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsDecreaseQuantityCreate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<CartItem>>},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsDecreaseQuantityCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Increase item quantity.
 */
export const checkoutItemsIncreaseQuantityCreate = (
    id: string,
    cartItem: BodyType<NonReadonly<CartItem>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CartItem>(
      {url: `/api/checkout/items/${id}/increase_quantity/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cartItem, signal
    },
      );
    }
  


export const getCheckoutItemsIncreaseQuantityCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsIncreaseQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsIncreaseQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext> => {

const mutationKey = ['checkoutItemsIncreaseQuantityCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsIncreaseQuantityCreate>>, {id: string;data: BodyType<NonReadonly<CartItem>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutItemsIncreaseQuantityCreate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsIncreaseQuantityCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsIncreaseQuantityCreate>>>
    export type CheckoutItemsIncreaseQuantityCreateMutationBody = BodyType<NonReadonly<CartItem>>
    export type CheckoutItemsIncreaseQuantityCreateMutationError = ErrorType<unknown>

    export const useCheckoutItemsIncreaseQuantityCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsIncreaseQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsIncreaseQuantityCreate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<CartItem>>},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsIncreaseQuantityCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Update item quantity.
 */
export const checkoutItemsUpdateQuantityCreate = (
    id: string,
    cartItem: BodyType<NonReadonly<CartItem>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<CartItem>(
      {url: `/api/checkout/items/${id}/update_quantity/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cartItem, signal
    },
      );
    }
  


export const getCheckoutItemsUpdateQuantityCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsUpdateQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsUpdateQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext> => {

const mutationKey = ['checkoutItemsUpdateQuantityCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutItemsUpdateQuantityCreate>>, {id: string;data: BodyType<NonReadonly<CartItem>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutItemsUpdateQuantityCreate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutItemsUpdateQuantityCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutItemsUpdateQuantityCreate>>>
    export type CheckoutItemsUpdateQuantityCreateMutationBody = BodyType<NonReadonly<CartItem>>
    export type CheckoutItemsUpdateQuantityCreateMutationError = ErrorType<unknown>

    export const useCheckoutItemsUpdateQuantityCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutItemsUpdateQuantityCreate>>, TError,{id: string;data: BodyType<NonReadonly<CartItem>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutItemsUpdateQuantityCreate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<CartItem>>},
        TContext
      > => {

      const mutationOptions = getCheckoutItemsUpdateQuantityCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutOrderNotesList = (
    params?: CheckoutOrderNotesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedOrderProcessingNoteList>(
      {url: `/api/checkout/order-notes/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutOrderNotesListQueryKey = (params?: CheckoutOrderNotesListParams,) => {
    return [`/api/checkout/order-notes/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutOrderNotesListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError = ErrorType<unknown>>(params?: CheckoutOrderNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutOrderNotesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutOrderNotesList>>> = ({ signal }) => checkoutOrderNotesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutOrderNotesListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutOrderNotesList>>>
export type CheckoutOrderNotesListQueryError = ErrorType<unknown>


export function useCheckoutOrderNotesList<TData = Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutOrderNotesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrderNotesList>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrderNotesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrderNotesList<TData = Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrderNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrderNotesList>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrderNotesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrderNotesList<TData = Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrderNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutOrderNotesList<TData = Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrderNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutOrderNotesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutOrderNotesCreate = (
    orderProcessingNote: BodyType<NonReadonly<OrderProcessingNote>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<OrderProcessingNote>(
      {url: `/api/checkout/order-notes/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderProcessingNote, signal
    },
      );
    }
  


export const getCheckoutOrderNotesCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesCreate>>, TError,{data: BodyType<NonReadonly<OrderProcessingNote>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesCreate>>, TError,{data: BodyType<NonReadonly<OrderProcessingNote>>}, TContext> => {

const mutationKey = ['checkoutOrderNotesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrderNotesCreate>>, {data: BodyType<NonReadonly<OrderProcessingNote>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutOrderNotesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrderNotesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrderNotesCreate>>>
    export type CheckoutOrderNotesCreateMutationBody = BodyType<NonReadonly<OrderProcessingNote>>
    export type CheckoutOrderNotesCreateMutationError = ErrorType<unknown>

    export const useCheckoutOrderNotesCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesCreate>>, TError,{data: BodyType<NonReadonly<OrderProcessingNote>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrderNotesCreate>>,
        TError,
        {data: BodyType<NonReadonly<OrderProcessingNote>>},
        TContext
      > => {

      const mutationOptions = getCheckoutOrderNotesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutOrderNotesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<OrderProcessingNote>(
      {url: `/api/checkout/order-notes/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutOrderNotesRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/order-notes/${id}/`] as const;
    }

    
export const getCheckoutOrderNotesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutOrderNotesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>> = ({ signal }) => checkoutOrderNotesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutOrderNotesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>>
export type CheckoutOrderNotesRetrieveQueryError = ErrorType<unknown>


export function useCheckoutOrderNotesRetrieve<TData = Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrderNotesRetrieve<TData = Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrderNotesRetrieve<TData = Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutOrderNotesRetrieve<TData = Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrderNotesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutOrderNotesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutOrderNotesUpdate = (
    id: number,
    orderProcessingNote: BodyType<NonReadonly<OrderProcessingNote>>,
 ) => {
      
      
      return shopInstance<OrderProcessingNote>(
      {url: `/api/checkout/order-notes/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderProcessingNote
    },
      );
    }
  


export const getCheckoutOrderNotesUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<OrderProcessingNote>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<OrderProcessingNote>>}, TContext> => {

const mutationKey = ['checkoutOrderNotesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrderNotesUpdate>>, {id: number;data: BodyType<NonReadonly<OrderProcessingNote>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutOrderNotesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrderNotesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrderNotesUpdate>>>
    export type CheckoutOrderNotesUpdateMutationBody = BodyType<NonReadonly<OrderProcessingNote>>
    export type CheckoutOrderNotesUpdateMutationError = ErrorType<unknown>

    export const useCheckoutOrderNotesUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesUpdate>>, TError,{id: number;data: BodyType<NonReadonly<OrderProcessingNote>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrderNotesUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<OrderProcessingNote>>},
        TContext
      > => {

      const mutationOptions = getCheckoutOrderNotesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutOrderNotesPartialUpdate = (
    id: number,
    patchedOrderProcessingNote: BodyType<NonReadonly<PatchedOrderProcessingNote>>,
 ) => {
      
      
      return shopInstance<OrderProcessingNote>(
      {url: `/api/checkout/order-notes/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedOrderProcessingNote
    },
      );
    }
  


export const getCheckoutOrderNotesPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedOrderProcessingNote>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedOrderProcessingNote>>}, TContext> => {

const mutationKey = ['checkoutOrderNotesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrderNotesPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedOrderProcessingNote>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutOrderNotesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrderNotesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrderNotesPartialUpdate>>>
    export type CheckoutOrderNotesPartialUpdateMutationBody = BodyType<NonReadonly<PatchedOrderProcessingNote>>
    export type CheckoutOrderNotesPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutOrderNotesPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedOrderProcessingNote>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrderNotesPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedOrderProcessingNote>>},
        TContext
      > => {

      const mutationOptions = getCheckoutOrderNotesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutOrderNotesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/order-notes/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutOrderNotesDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutOrderNotesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrderNotesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutOrderNotesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrderNotesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrderNotesDestroy>>>
    
    export type CheckoutOrderNotesDestroyMutationError = ErrorType<unknown>

    export const useCheckoutOrderNotesDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrderNotesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrderNotesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutOrderNotesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Retrieve a list of orders for the current user
 * @summary Get current user's orders
 */
export const checkoutOrdersList = (
    params?: CheckoutOrdersListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedOrdersListResponseList>(
      {url: `/api/checkout/orders/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutOrdersListQueryKey = (params?: CheckoutOrdersListParams,) => {
    return [`/api/checkout/orders/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutOrdersListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutOrdersList>>, TError = ErrorType<unknown>>(params?: CheckoutOrdersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutOrdersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutOrdersList>>> = ({ signal }) => checkoutOrdersList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutOrdersListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersList>>>
export type CheckoutOrdersListQueryError = ErrorType<unknown>


export function useCheckoutOrdersList<TData = Awaited<ReturnType<typeof checkoutOrdersList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutOrdersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrdersList>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrdersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrdersList<TData = Awaited<ReturnType<typeof checkoutOrdersList>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrdersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrdersList>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrdersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrdersList<TData = Awaited<ReturnType<typeof checkoutOrdersList>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrdersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user's orders
 */

export function useCheckoutOrdersList<TData = Awaited<ReturnType<typeof checkoutOrdersList>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrdersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutOrdersListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Orders: users read their own; employees/admins full CRUD across all.
 */
export const checkoutOrdersCreate = (
    order: BodyType<NonReadonly<Order>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Order>(
      {url: `/api/checkout/orders/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: order, signal
    },
      );
    }
  


export const getCheckoutOrdersCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersCreate>>, TError,{data: BodyType<NonReadonly<Order>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersCreate>>, TError,{data: BodyType<NonReadonly<Order>>}, TContext> => {

const mutationKey = ['checkoutOrdersCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrdersCreate>>, {data: BodyType<NonReadonly<Order>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutOrdersCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrdersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersCreate>>>
    export type CheckoutOrdersCreateMutationBody = BodyType<NonReadonly<Order>>
    export type CheckoutOrdersCreateMutationError = ErrorType<unknown>

    export const useCheckoutOrdersCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersCreate>>, TError,{data: BodyType<NonReadonly<Order>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrdersCreate>>,
        TError,
        {data: BodyType<NonReadonly<Order>>},
        TContext
      > => {

      const mutationOptions = getCheckoutOrdersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Retrieve details of a specific order
 * @summary Get order details
 */
export const checkoutOrdersRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<OrderDetail>(
      {url: `/api/checkout/orders/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutOrdersRetrieveQueryKey = (id: string,) => {
    return [`/api/checkout/orders/${id}/`] as const;
    }

    
export const getCheckoutOrdersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutOrdersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>> = ({ signal }) => checkoutOrdersRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutOrdersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>>
export type CheckoutOrdersRetrieveQueryError = ErrorType<unknown>


export function useCheckoutOrdersRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrdersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrdersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrdersRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrdersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrdersRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrdersRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get order details
 */

export function useCheckoutOrdersRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutOrdersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Orders: users read their own; employees/admins full CRUD across all.
 */
export const checkoutOrdersUpdate = (
    id: string,
    order: BodyType<NonReadonly<Order>>,
 ) => {
      
      
      return shopInstance<Order>(
      {url: `/api/checkout/orders/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: order
    },
      );
    }
  


export const getCheckoutOrdersUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersUpdate>>, TError,{id: string;data: BodyType<NonReadonly<Order>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersUpdate>>, TError,{id: string;data: BodyType<NonReadonly<Order>>}, TContext> => {

const mutationKey = ['checkoutOrdersUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrdersUpdate>>, {id: string;data: BodyType<NonReadonly<Order>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutOrdersUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrdersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersUpdate>>>
    export type CheckoutOrdersUpdateMutationBody = BodyType<NonReadonly<Order>>
    export type CheckoutOrdersUpdateMutationError = ErrorType<unknown>

    export const useCheckoutOrdersUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersUpdate>>, TError,{id: string;data: BodyType<NonReadonly<Order>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrdersUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<Order>>},
        TContext
      > => {

      const mutationOptions = getCheckoutOrdersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Orders: users read their own; employees/admins full CRUD across all.
 */
export const checkoutOrdersPartialUpdate = (
    id: string,
    patchedOrder: BodyType<NonReadonly<PatchedOrder>>,
 ) => {
      
      
      return shopInstance<Order>(
      {url: `/api/checkout/orders/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedOrder
    },
      );
    }
  


export const getCheckoutOrdersPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedOrder>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedOrder>>}, TContext> => {

const mutationKey = ['checkoutOrdersPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrdersPartialUpdate>>, {id: string;data: BodyType<NonReadonly<PatchedOrder>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutOrdersPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrdersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersPartialUpdate>>>
    export type CheckoutOrdersPartialUpdateMutationBody = BodyType<NonReadonly<PatchedOrder>>
    export type CheckoutOrdersPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutOrdersPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersPartialUpdate>>, TError,{id: string;data: BodyType<NonReadonly<PatchedOrder>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrdersPartialUpdate>>,
        TError,
        {id: string;data: BodyType<NonReadonly<PatchedOrder>>},
        TContext
      > => {

      const mutationOptions = getCheckoutOrdersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutOrdersDestroy = (
    id: string,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/orders/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutOrdersDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersDestroy>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['checkoutOrdersDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutOrdersDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  checkoutOrdersDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutOrdersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersDestroy>>>
    
    export type CheckoutOrdersDestroyMutationError = ErrorType<unknown>

    export const useCheckoutOrdersDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutOrdersDestroy>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutOrdersDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCheckoutOrdersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Download CSV of orders for the given period (24h, 7d, 30d, lifetime)
 * @summary Export orders CSV
 */
export const checkoutOrdersExportCsvRetrieve = (
    params?: CheckoutOrdersExportCsvRetrieveParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Blob>(
      {url: `/api/checkout/orders/export.csv`, method: 'GET',
        params,
        responseType: 'blob', signal
    },
      );
    }
  

export const getCheckoutOrdersExportCsvRetrieveQueryKey = (params?: CheckoutOrdersExportCsvRetrieveParams,) => {
    return [`/api/checkout/orders/export.csv`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutOrdersExportCsvRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError = ErrorType<unknown>>(params?: CheckoutOrdersExportCsvRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutOrdersExportCsvRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>> = ({ signal }) => checkoutOrdersExportCsvRetrieve(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutOrdersExportCsvRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>>
export type CheckoutOrdersExportCsvRetrieveQueryError = ErrorType<unknown>


export function useCheckoutOrdersExportCsvRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutOrdersExportCsvRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrdersExportCsvRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrdersExportCsvRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutOrdersExportCsvRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrdersExportCsvRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export orders CSV
 */

export function useCheckoutOrdersExportCsvRetrieve<TData = Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError = ErrorType<unknown>>(
 params?: CheckoutOrdersExportCsvRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutOrdersExportCsvRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutOrdersExportCsvRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutPaymentsList = (
    params?: CheckoutPaymentsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedPaymentList>(
      {url: `/api/checkout/payments/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutPaymentsListQueryKey = (params?: CheckoutPaymentsListParams,) => {
    return [`/api/checkout/payments/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutPaymentsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutPaymentsList>>, TError = ErrorType<unknown>>(params?: CheckoutPaymentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutPaymentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutPaymentsList>>> = ({ signal }) => checkoutPaymentsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutPaymentsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutPaymentsList>>>
export type CheckoutPaymentsListQueryError = ErrorType<unknown>


export function useCheckoutPaymentsList<TData = Awaited<ReturnType<typeof checkoutPaymentsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutPaymentsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutPaymentsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutPaymentsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutPaymentsList<TData = Awaited<ReturnType<typeof checkoutPaymentsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutPaymentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutPaymentsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutPaymentsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutPaymentsList<TData = Awaited<ReturnType<typeof checkoutPaymentsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutPaymentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutPaymentsList<TData = Awaited<ReturnType<typeof checkoutPaymentsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutPaymentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutPaymentsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutPaymentsCreate = (
    payment: BodyType<NonReadonly<Payment>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Payment>(
      {url: `/api/checkout/payments/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: payment, signal
    },
      );
    }
  


export const getCheckoutPaymentsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsCreate>>, TError,{data: BodyType<NonReadonly<Payment>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsCreate>>, TError,{data: BodyType<NonReadonly<Payment>>}, TContext> => {

const mutationKey = ['checkoutPaymentsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutPaymentsCreate>>, {data: BodyType<NonReadonly<Payment>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutPaymentsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutPaymentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutPaymentsCreate>>>
    export type CheckoutPaymentsCreateMutationBody = BodyType<NonReadonly<Payment>>
    export type CheckoutPaymentsCreateMutationError = ErrorType<unknown>

    export const useCheckoutPaymentsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsCreate>>, TError,{data: BodyType<NonReadonly<Payment>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutPaymentsCreate>>,
        TError,
        {data: BodyType<NonReadonly<Payment>>},
        TContext
      > => {

      const mutationOptions = getCheckoutPaymentsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutPaymentsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Payment>(
      {url: `/api/checkout/payments/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutPaymentsRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/payments/${id}/`] as const;
    }

    
export const getCheckoutPaymentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutPaymentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>> = ({ signal }) => checkoutPaymentsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutPaymentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>>
export type CheckoutPaymentsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutPaymentsRetrieve<TData = Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutPaymentsRetrieve<TData = Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutPaymentsRetrieve<TData = Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutPaymentsRetrieve<TData = Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutPaymentsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutPaymentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutPaymentsUpdate = (
    id: number,
    payment: BodyType<NonReadonly<Payment>>,
 ) => {
      
      
      return shopInstance<Payment>(
      {url: `/api/checkout/payments/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: payment
    },
      );
    }
  


export const getCheckoutPaymentsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Payment>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Payment>>}, TContext> => {

const mutationKey = ['checkoutPaymentsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutPaymentsUpdate>>, {id: number;data: BodyType<NonReadonly<Payment>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutPaymentsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutPaymentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutPaymentsUpdate>>>
    export type CheckoutPaymentsUpdateMutationBody = BodyType<NonReadonly<Payment>>
    export type CheckoutPaymentsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutPaymentsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Payment>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutPaymentsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Payment>>},
        TContext
      > => {

      const mutationOptions = getCheckoutPaymentsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutPaymentsPartialUpdate = (
    id: number,
    patchedPayment: BodyType<NonReadonly<PatchedPayment>>,
 ) => {
      
      
      return shopInstance<Payment>(
      {url: `/api/checkout/payments/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedPayment
    },
      );
    }
  


export const getCheckoutPaymentsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedPayment>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedPayment>>}, TContext> => {

const mutationKey = ['checkoutPaymentsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutPaymentsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedPayment>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutPaymentsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutPaymentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutPaymentsPartialUpdate>>>
    export type CheckoutPaymentsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedPayment>>
    export type CheckoutPaymentsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutPaymentsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedPayment>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutPaymentsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedPayment>>},
        TContext
      > => {

      const mutationOptions = getCheckoutPaymentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutPaymentsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/payments/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutPaymentsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutPaymentsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutPaymentsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutPaymentsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutPaymentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutPaymentsDestroy>>>
    
    export type CheckoutPaymentsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutPaymentsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutPaymentsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutPaymentsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutPaymentsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShipmentsList = (
    params?: CheckoutShipmentsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedShipmentList>(
      {url: `/api/checkout/shipments/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutShipmentsListQueryKey = (params?: CheckoutShipmentsListParams,) => {
    return [`/api/checkout/shipments/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutShipmentsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutShipmentsList>>, TError = ErrorType<unknown>>(params?: CheckoutShipmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutShipmentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutShipmentsList>>> = ({ signal }) => checkoutShipmentsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutShipmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutShipmentsList>>>
export type CheckoutShipmentsListQueryError = ErrorType<unknown>


export function useCheckoutShipmentsList<TData = Awaited<ReturnType<typeof checkoutShipmentsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutShipmentsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShipmentsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutShipmentsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShipmentsList<TData = Awaited<ReturnType<typeof checkoutShipmentsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutShipmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShipmentsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutShipmentsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShipmentsList<TData = Awaited<ReturnType<typeof checkoutShipmentsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutShipmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutShipmentsList<TData = Awaited<ReturnType<typeof checkoutShipmentsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutShipmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutShipmentsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShipmentsCreate = (
    shipment: BodyType<NonReadonly<Shipment>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Shipment>(
      {url: `/api/checkout/shipments/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: shipment, signal
    },
      );
    }
  


export const getCheckoutShipmentsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsCreate>>, TError,{data: BodyType<NonReadonly<Shipment>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsCreate>>, TError,{data: BodyType<NonReadonly<Shipment>>}, TContext> => {

const mutationKey = ['checkoutShipmentsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShipmentsCreate>>, {data: BodyType<NonReadonly<Shipment>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutShipmentsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShipmentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShipmentsCreate>>>
    export type CheckoutShipmentsCreateMutationBody = BodyType<NonReadonly<Shipment>>
    export type CheckoutShipmentsCreateMutationError = ErrorType<unknown>

    export const useCheckoutShipmentsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsCreate>>, TError,{data: BodyType<NonReadonly<Shipment>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShipmentsCreate>>,
        TError,
        {data: BodyType<NonReadonly<Shipment>>},
        TContext
      > => {

      const mutationOptions = getCheckoutShipmentsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShipmentsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Shipment>(
      {url: `/api/checkout/shipments/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutShipmentsRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/shipments/${id}/`] as const;
    }

    
export const getCheckoutShipmentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutShipmentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>> = ({ signal }) => checkoutShipmentsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutShipmentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>>
export type CheckoutShipmentsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutShipmentsRetrieve<TData = Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShipmentsRetrieve<TData = Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShipmentsRetrieve<TData = Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutShipmentsRetrieve<TData = Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShipmentsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutShipmentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShipmentsUpdate = (
    id: number,
    shipment: BodyType<NonReadonly<Shipment>>,
 ) => {
      
      
      return shopInstance<Shipment>(
      {url: `/api/checkout/shipments/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: shipment
    },
      );
    }
  


export const getCheckoutShipmentsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Shipment>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Shipment>>}, TContext> => {

const mutationKey = ['checkoutShipmentsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShipmentsUpdate>>, {id: number;data: BodyType<NonReadonly<Shipment>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutShipmentsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShipmentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShipmentsUpdate>>>
    export type CheckoutShipmentsUpdateMutationBody = BodyType<NonReadonly<Shipment>>
    export type CheckoutShipmentsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutShipmentsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<Shipment>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShipmentsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<Shipment>>},
        TContext
      > => {

      const mutationOptions = getCheckoutShipmentsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShipmentsPartialUpdate = (
    id: number,
    patchedShipment: BodyType<NonReadonly<PatchedShipment>>,
 ) => {
      
      
      return shopInstance<Shipment>(
      {url: `/api/checkout/shipments/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedShipment
    },
      );
    }
  


export const getCheckoutShipmentsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedShipment>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedShipment>>}, TContext> => {

const mutationKey = ['checkoutShipmentsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShipmentsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedShipment>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutShipmentsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShipmentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShipmentsPartialUpdate>>>
    export type CheckoutShipmentsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedShipment>>
    export type CheckoutShipmentsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutShipmentsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedShipment>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShipmentsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedShipment>>},
        TContext
      > => {

      const mutationOptions = getCheckoutShipmentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutShipmentsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/shipments/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutShipmentsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutShipmentsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShipmentsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutShipmentsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShipmentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShipmentsDestroy>>>
    
    export type CheckoutShipmentsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutShipmentsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShipmentsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShipmentsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutShipmentsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShippingMethodsList = (
    params?: CheckoutShippingMethodsListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ShippingMethod[]>(
      {url: `/api/checkout/shipping-methods/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckoutShippingMethodsListQueryKey = (params?: CheckoutShippingMethodsListParams,) => {
    return [`/api/checkout/shipping-methods/`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckoutShippingMethodsListQueryOptions = <TData = Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError = ErrorType<unknown>>(params?: CheckoutShippingMethodsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutShippingMethodsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutShippingMethodsList>>> = ({ signal }) => checkoutShippingMethodsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutShippingMethodsListQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutShippingMethodsList>>>
export type CheckoutShippingMethodsListQueryError = ErrorType<unknown>


export function useCheckoutShippingMethodsList<TData = Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError = ErrorType<unknown>>(
 params: undefined |  CheckoutShippingMethodsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShippingMethodsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutShippingMethodsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShippingMethodsList<TData = Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutShippingMethodsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShippingMethodsList>>,
          TError,
          Awaited<ReturnType<typeof checkoutShippingMethodsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShippingMethodsList<TData = Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutShippingMethodsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutShippingMethodsList<TData = Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError = ErrorType<unknown>>(
 params?: CheckoutShippingMethodsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutShippingMethodsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShippingMethodsCreate = (
    shippingMethod: BodyType<NonReadonly<ShippingMethod>>,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ShippingMethod>(
      {url: `/api/checkout/shipping-methods/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: shippingMethod, signal
    },
      );
    }
  


export const getCheckoutShippingMethodsCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsCreate>>, TError,{data: BodyType<NonReadonly<ShippingMethod>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsCreate>>, TError,{data: BodyType<NonReadonly<ShippingMethod>>}, TContext> => {

const mutationKey = ['checkoutShippingMethodsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShippingMethodsCreate>>, {data: BodyType<NonReadonly<ShippingMethod>>}> = (props) => {
          const {data} = props ?? {};

          return  checkoutShippingMethodsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShippingMethodsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShippingMethodsCreate>>>
    export type CheckoutShippingMethodsCreateMutationBody = BodyType<NonReadonly<ShippingMethod>>
    export type CheckoutShippingMethodsCreateMutationError = ErrorType<unknown>

    export const useCheckoutShippingMethodsCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsCreate>>, TError,{data: BodyType<NonReadonly<ShippingMethod>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShippingMethodsCreate>>,
        TError,
        {data: BodyType<NonReadonly<ShippingMethod>>},
        TContext
      > => {

      const mutationOptions = getCheckoutShippingMethodsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShippingMethodsRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<ShippingMethod>(
      {url: `/api/checkout/shipping-methods/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getCheckoutShippingMethodsRetrieveQueryKey = (id: number,) => {
    return [`/api/checkout/shipping-methods/${id}/`] as const;
    }

    
export const getCheckoutShippingMethodsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError = ErrorType<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckoutShippingMethodsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>> = ({ signal }) => checkoutShippingMethodsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckoutShippingMethodsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>>
export type CheckoutShippingMethodsRetrieveQueryError = ErrorType<unknown>


export function useCheckoutShippingMethodsRetrieve<TData = Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShippingMethodsRetrieve<TData = Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckoutShippingMethodsRetrieve<TData = Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCheckoutShippingMethodsRetrieve<TData = Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError = ErrorType<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkoutShippingMethodsRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckoutShippingMethodsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShippingMethodsUpdate = (
    id: number,
    shippingMethod: BodyType<NonReadonly<ShippingMethod>>,
 ) => {
      
      
      return shopInstance<ShippingMethod>(
      {url: `/api/checkout/shipping-methods/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: shippingMethod
    },
      );
    }
  


export const getCheckoutShippingMethodsUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ShippingMethod>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ShippingMethod>>}, TContext> => {

const mutationKey = ['checkoutShippingMethodsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShippingMethodsUpdate>>, {id: number;data: BodyType<NonReadonly<ShippingMethod>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutShippingMethodsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShippingMethodsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShippingMethodsUpdate>>>
    export type CheckoutShippingMethodsUpdateMutationBody = BodyType<NonReadonly<ShippingMethod>>
    export type CheckoutShippingMethodsUpdateMutationError = ErrorType<unknown>

    export const useCheckoutShippingMethodsUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsUpdate>>, TError,{id: number;data: BodyType<NonReadonly<ShippingMethod>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShippingMethodsUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<ShippingMethod>>},
        TContext
      > => {

      const mutationOptions = getCheckoutShippingMethodsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Base ViewSet with built-in ProtectedError handling for delete operations.
All ViewSets should inherit from this instead of ModelViewSet directly.
 */
export const checkoutShippingMethodsPartialUpdate = (
    id: number,
    patchedShippingMethod: BodyType<NonReadonly<PatchedShippingMethod>>,
 ) => {
      
      
      return shopInstance<ShippingMethod>(
      {url: `/api/checkout/shipping-methods/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedShippingMethod
    },
      );
    }
  


export const getCheckoutShippingMethodsPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedShippingMethod>>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedShippingMethod>>}, TContext> => {

const mutationKey = ['checkoutShippingMethodsPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShippingMethodsPartialUpdate>>, {id: number;data: BodyType<NonReadonly<PatchedShippingMethod>>}> = (props) => {
          const {id,data} = props ?? {};

          return  checkoutShippingMethodsPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShippingMethodsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShippingMethodsPartialUpdate>>>
    export type CheckoutShippingMethodsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedShippingMethod>>
    export type CheckoutShippingMethodsPartialUpdateMutationError = ErrorType<unknown>

    export const useCheckoutShippingMethodsPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsPartialUpdate>>, TError,{id: number;data: BodyType<NonReadonly<PatchedShippingMethod>>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShippingMethodsPartialUpdate>>,
        TError,
        {id: number;data: BodyType<NonReadonly<PatchedShippingMethod>>},
        TContext
      > => {

      const mutationOptions = getCheckoutShippingMethodsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle deletion with foreign key constraint protection.
 */
export const checkoutShippingMethodsDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<unknown>(
      {url: `/api/checkout/shipping-methods/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getCheckoutShippingMethodsDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['checkoutShippingMethodsDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutShippingMethodsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  checkoutShippingMethodsDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutShippingMethodsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutShippingMethodsDestroy>>>
    
    export type CheckoutShippingMethodsDestroyMutationError = ErrorType<unknown>

    export const useCheckoutShippingMethodsDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutShippingMethodsDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutShippingMethodsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCheckoutShippingMethodsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    