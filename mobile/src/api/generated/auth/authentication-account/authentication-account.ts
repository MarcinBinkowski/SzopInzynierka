/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * django-allauth: Headless API
 * # Introduction

Welcome to the django-allauth API specification. This API is intended to be
consumed by two different kind of clients:

- Web applications running in a **browser** context. For example, a
  single-page React application, to which the end user can navigate using a web
  browser.

- Applications, **apps** for short, executing in non-browser contexts. For example,
  a mobile Android or iOS application.

The security considerations for these two usage types are different. In a
browser context, cookies play a role.  Without taking special precautions, your
web application may be vulnerable to Cross-Site Request Forgery attacks.  For
mobile applications, this does not apply.

The API can be used for both use cases. Differences in handling of security is
automatically adjusted for, based on the request path used to make the API call.
For example, signing up can either be done using the
`/_allauth/browser/v1/auth/signup` or the `/_allauth/app/v1/auth/signup`
endpoint. For the **browser** usage, session cookies and CSRF protection
applies. For the **app** usage, cookies play no role, instead, a session token
is used.  The paths of all endpoints are documented in the form of
`/_allauth/{client}/v1/auth/signup`. Depending on the client type (`{client}`),
there may be slight differences in request/response handling.  This is
documented where applicable.


# Scope

The following functionality is all in scope and handled as part of this API:

- Regular accounts:
  - Login
  - Signup
  - Password forgotten
  - Manage email (add, remove, verify, select a different primary)
  - Change password.
  - Verification of email addresses.
- Two-Factor Authentication:
  - Authentication using an authenticator code
  - (De)activate TOTP
  - (Re)generate recovery codes
  - "Trust this browser"
- Third-party providers:
  - Authenticate by performing a browser-level redirect (synchronous request).
  - Authenticate by means of a provider token.
  - Connect additional provider accounts.
  - Disconnect existing provider accounts.
  - Setting a password in case no password was set, yet.
  - Querying additional information before signing up.
- Session management:
  - Listing all sessions for a user.
  - Signing out of any of those sessions.


# Browser Usage

For web applications running in a browser, routing needs to be setup correctly
such that the sessions initiated at the backend are accessible in the frontend.

## Routing

When using the API in a browser context, regular Django sessions are used, along
with the usual session cookies. There are several options for setting up the
routing of your application.


###  Single Domain Routing

With single domain, path-based routing, both your frontend and backend are
served from the same domain, for example `https://app.org`. You will have to
make sure that some paths are served by the frontend, and others by the backend.


### Sub-domain Routing

With sub-domain based routing, the frontend and backend are served from
different domains.  However, as session cookies are used, these different
domains must share common main domain.

For example, you may use `app.project.org` for the frontend, which
interfaces with the backend over at `backend.project.org`.  In this
setup, Django will need to be configured with:

```
SESSION_COOKIE_DOMAIN = "project.org"
CSRF_COOKIE_DOMAIN = "project.org"
```

If your organization hosts unrelated applications, for example, a CMS for
marketing purposes, on the top level domain (`project.org`), it is not advisable
to set the session cookie domain to `project.org`, as those other applications
could get access to the session cookie. In that case, it is advised to use
`backend.app.project.org` for the backend, and set the session cookie domain to
`app.project.org`.


# App Usage

For app based usage, cookies play no role, yet, sessions are still used. When a
user walks through the authentication flow, a session is created.  Having an
authenticated session is proof that the user is allowed to further interact with
the backend. Unauthenticated sessions are also needed to remember state while
the user proceeds to go over the required steps necessary to authenticate.


## Session Tokens

Given that there is no cookie to point to the session, the header
`X-Session-Token` is used instead. The way of working is as follows:

- If you do not have a session token yet, do not send the `X-Session-Token` header.

- When making requests, session tokens can appear in the metadata
  (`meta.session_token`) of authentication related responses. If a session
  token appears, store it (overwriting any previous session token), and ensure
  to add the token to the `X-Session-Token` header of all subsequent requests.

- When receiving an authentication related response with status code 410
  (`Gone`), that is meant to indicate that the session is no longer valid.
  Remove the session token and start clean.


## Access Tokens

While session tokens are required to handle the authentication process,
depending on your requirements, a different type of token may be needed once
authenticated.

For example, your app likely needs access to other APIs as well. These APIs may
 even be implemented using different technologies, in which case having a
 stateless token, possibly a JWT encoding the user ID, might be a good fit.

In this API and its implementation no assumptions, and no (limiting) design
decisions are made in this regard. The token strategy of django-allauth is
pluggable, such that you can expose your own access token when the user
authenticates. As for as the API specification is concerned, the access token
will appear in the response of metadata (`meta.access_token`) of a successful
authentication request. How you can customize the token strategy can be found
over at the documentation of the `allauth.headless` Django application.


# Responses

Unless documented otherwise, responses are objects with the following
properties:
- The `status`, matching the HTTP status code.
- Data, if any, is returned as part of the `data` key.
- Metadata, if any, is returned as part of the `meta` key.
- Errors, if any, are listed in the `errors` key.


# Authentication Flows

In order to become authenticated, the user must complete a flow, potentially
consisting of several steps. For example:
- A login, after which the user is authenticated.
- A Login, followed by two-factor authentication, after which the user is
  authenticated.
- A signup, followed by mandatory email verification, after which the user is
  authenticated.

The API signals to the client that (re)authentication is required by means of a
`401` or `410` status code:
- Not authenticated: status `401`.
- Re-authentication required: status `401`, with `meta.is_authenticated = true`.
- Invalid session: status `410`. This only occurs for clients of type `app`.

All authentication related responses have status `401` or `410`, and,
`meta.is_authenticated` indicating whether authentication, or re-authentication
is required.

The flows the client can perform to initiate or complete the authentication are
communicates as part of authentication related responses. The authentication can
be initiated by means of these flows:
- Login using a local account (`login`).
- Signup for a local account (`signup`).
- Login or signup using the third-party provider redirect flow (`provider_redirect`).
- Login or signup by handing over a third-party provider retrieved elsewhere (`provider_token`).
- Login using a special code (`login_by_code`).
- Login using a passkey (`mfa_login_webauthn`).
- Signup using a passkey (`mfa_signup_webauthn`).

Depending on the state of the account, and the configuration of django-allauth, the flows above
can either lead to becoming directly authenticated, or, to followup flows:
- Provider signup (`provider_signup`).
- Email verification (`verify_email`).
- Phone verification (`phone_email`).
- Two-factor authentication required (TOTP, recovery codes, or WebAuthn) (`mfa_authenticate`).
- Trust this browser (`mfa_trust`).

While authenticated, re-authentication may be required to safeguard the account when sensitive actions
are performed. The re-authentication flows are the following:
- Re-authenticate using password (`reauthenticate`).
- Re-authenticate using a 2FA authenticator (TOTP, recovery codes, or WebAuthn) (`mfa_reauthenticate`).


# Security Considerations

## Input Sanitization

The Django framework, by design, does *not* perform input sanitization. For
example, there is nothing preventing end users from signing up using `<script>`
or `Robert'); DROP TABLE students` as a first name. Django relies on its
template language for proper escaping of such values and mitigate any XSS
attacks.

As a result, any `allauth.headless` client **must** have proper XSS protection
in place as well. Be prepared that, for example, the WebAuthn endpoints could
return authenticator names as follows:

    {
      "name": "<script>alert(1)</script>",
      "credential": {
        "type": "public-key",
        ...
      }
    }
 * OpenAPI spec version: 1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthenticatedByPasswordResponse,
  AuthenticatedResponse,
  AuthenticationResponse,
  ConflictResponse,
  EmailVerificationInfoResponse,
  ErrorResponse,
  ForbiddenResponse,
  LoginBody,
  ReauthenticateBody,
  SignupBody,
  StatusOKResponse,
  TooManyRequestsResponse,
  UnauthenticatedResponse,
  VerifyEmailBody,
  VerifyPhoneBody
} from '.././schemas';

import { authInstance } from '../../../auth-mutator';
import type { ErrorType , BodyType } from '../../../auth-mutator';




/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const postAllauthClientV1AuthLogin = (
    client: 'app' | 'browser',
    loginBody: BodyType<LoginBody>,
 signal?: AbortSignal
) => {
      
      
      return authInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginBody, signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthLoginMutationOptions = <TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, TError,{client: 'app' | 'browser';data: BodyType<LoginBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, TError,{client: 'app' | 'browser';data: BodyType<LoginBody>}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, {client: 'app' | 'browser';data: BodyType<LoginBody>}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthLogin(client,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>>
    export type PostAllauthClientV1AuthLoginMutationBody = BodyType<LoginBody>
    export type PostAllauthClientV1AuthLoginMutationError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>

    /**
 * @summary Login
 */
export const usePostAllauthClientV1AuthLogin = <TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, TError,{client: 'app' | 'browser';data: BodyType<LoginBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
        TError,
        {client: 'app' | 'browser';data: BodyType<LoginBody>},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Whether or not `username`, `email`, `phone` or combination of those are
required depends on the configuration of django-allauth. Additionally,
if a custom signup form is used there may be other custom properties
required.

 * @summary Signup
 */
export const postAllauthClientV1AuthSignup = (
    client: 'app' | 'browser',
    signupBody: BodyType<SignupBody>,
 signal?: AbortSignal
) => {
      
      
      return authInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signupBody, signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthSignupMutationOptions = <TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, TError,{client: 'app' | 'browser';data: BodyType<SignupBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, TError,{client: 'app' | 'browser';data: BodyType<SignupBody>}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthSignup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, {client: 'app' | 'browser';data: BodyType<SignupBody>}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthSignup(client,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>>
    export type PostAllauthClientV1AuthSignupMutationBody = BodyType<SignupBody>
    export type PostAllauthClientV1AuthSignupMutationError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>

    /**
 * @summary Signup
 */
export const usePostAllauthClientV1AuthSignup = <TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, TError,{client: 'app' | 'browser';data: BodyType<SignupBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
        TError,
        {client: 'app' | 'browser';data: BodyType<SignupBody>},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthSignupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getAllauthClientV1AuthEmailVerify = (
    client: 'app' | 'browser',
 signal?: AbortSignal
) => {
      
      
      return authInstance<EmailVerificationInfoResponse>(
      {url: `/_allauth/${client}/v1/auth/email/verify`, method: 'GET', signal
    },
      );
    }
  

export const getGetAllauthClientV1AuthEmailVerifyQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/email/verify`] as const;
    }

    
export const getGetAllauthClientV1AuthEmailVerifyQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorType<ErrorResponse | ConflictResponse>>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthEmailVerifyQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>> = ({ signal }) => getAllauthClientV1AuthEmailVerify(client, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthEmailVerifyQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>>
export type GetAllauthClientV1AuthEmailVerifyQueryError = ErrorType<ErrorResponse | ConflictResponse>


export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorType<ErrorResponse | ConflictResponse>>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorType<ErrorResponse | ConflictResponse>>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorType<ErrorResponse | ConflictResponse>>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get email verification information
 */

export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorType<ErrorResponse | ConflictResponse>>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthEmailVerifyQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

Note that a status code of 401 does not imply failure. It indicates that
the email verification was successful, yet, the user is still not signed
in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
`False`, a 401 is returned when verifying as part of login/signup.

 * @summary Verify an email
 */
export const postAllauthClientV1AuthEmailVerify = (
    client: 'app' | 'browser',
    verifyEmailBody: BodyType<VerifyEmailBody>,
 signal?: AbortSignal
) => {
      
      
      return authInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/email/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyEmailBody, signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthEmailVerifyMutationOptions = <TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, TError,{client: 'app' | 'browser';data: BodyType<VerifyEmailBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, TError,{client: 'app' | 'browser';data: BodyType<VerifyEmailBody>}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthEmailVerify'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, {client: 'app' | 'browser';data: BodyType<VerifyEmailBody>}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthEmailVerify(client,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthEmailVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>>
    export type PostAllauthClientV1AuthEmailVerifyMutationBody = BodyType<VerifyEmailBody>
    export type PostAllauthClientV1AuthEmailVerifyMutationError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>

    /**
 * @summary Verify an email
 */
export const usePostAllauthClientV1AuthEmailVerify = <TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, TError,{client: 'app' | 'browser';data: BodyType<VerifyEmailBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
        TError,
        {client: 'app' | 'browser';data: BodyType<VerifyEmailBody>},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthEmailVerifyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Requests a new email verification code.
Requires `ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend email verification code
 */
export const postAllauthClientV1AuthEmailVerifyResend = (
    client: 'app' | 'browser',
 signal?: AbortSignal
) => {
      
      
      return authInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/auth/email/verify/resend`, method: 'POST', signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthEmailVerifyResendMutationOptions = <TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthEmailVerifyResend'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  postAllauthClientV1AuthEmailVerifyResend(client,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthEmailVerifyResendMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>>
    
    export type PostAllauthClientV1AuthEmailVerifyResendMutationError = ErrorType<ConflictResponse | TooManyRequestsResponse>

    /**
 * @summary Resend email verification code
 */
export const usePostAllauthClientV1AuthEmailVerifyResend = <TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthEmailVerifyResendMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Complete the phone number verification process. Note that a status code
of 401 does not imply failure. It merely indicates that the phone number
verification was successful, yet, the user is still not signed in.

 * @summary Verify a phone number
 */
export const postAllauthClientV1AuthPhoneVerify = (
    client: 'app' | 'browser',
    verifyPhoneBody: BodyType<VerifyPhoneBody>,
 signal?: AbortSignal
) => {
      
      
      return authInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/phone/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyPhoneBody, signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthPhoneVerifyMutationOptions = <TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, TError,{client: 'app' | 'browser';data: BodyType<VerifyPhoneBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, TError,{client: 'app' | 'browser';data: BodyType<VerifyPhoneBody>}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthPhoneVerify'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, {client: 'app' | 'browser';data: BodyType<VerifyPhoneBody>}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthPhoneVerify(client,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthPhoneVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>>
    export type PostAllauthClientV1AuthPhoneVerifyMutationBody = BodyType<VerifyPhoneBody>
    export type PostAllauthClientV1AuthPhoneVerifyMutationError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>

    /**
 * @summary Verify a phone number
 */
export const usePostAllauthClientV1AuthPhoneVerify = <TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, TError,{client: 'app' | 'browser';data: BodyType<VerifyPhoneBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
        TError,
        {client: 'app' | 'browser';data: BodyType<VerifyPhoneBody>},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthPhoneVerifyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Requests a new phone number verification code.
Requires `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend phone number verification code
 */
export const postAllauthClientV1AuthPhoneVerifyResend = (
    client: 'app' | 'browser',
 signal?: AbortSignal
) => {
      
      
      return authInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/auth/phone/verify/resend`, method: 'POST', signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthPhoneVerifyResendMutationOptions = <TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthPhoneVerifyResend'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  postAllauthClientV1AuthPhoneVerifyResend(client,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthPhoneVerifyResendMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>>
    
    export type PostAllauthClientV1AuthPhoneVerifyResendMutationError = ErrorType<ConflictResponse | TooManyRequestsResponse>

    /**
 * @summary Resend phone number verification code
 */
export const usePostAllauthClientV1AuthPhoneVerifyResend = <TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthPhoneVerifyResendMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const postAllauthClientV1AuthReauthenticate = (
    client: 'app' | 'browser',
    reauthenticateBody: BodyType<ReauthenticateBody>,
 signal?: AbortSignal
) => {
      
      
      return authInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/reauthenticate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reauthenticateBody, signal
    },
      );
    }
  


export const getPostAllauthClientV1AuthReauthenticateMutationOptions = <TError = ErrorType<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, TError,{client: 'app' | 'browser';data: BodyType<ReauthenticateBody>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, TError,{client: 'app' | 'browser';data: BodyType<ReauthenticateBody>}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthReauthenticate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, {client: 'app' | 'browser';data: BodyType<ReauthenticateBody>}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthReauthenticate(client,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthReauthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>>
    export type PostAllauthClientV1AuthReauthenticateMutationBody = BodyType<ReauthenticateBody>
    export type PostAllauthClientV1AuthReauthenticateMutationError = ErrorType<ErrorResponse>

    /**
 * @summary Reauthenticate
 */
export const usePostAllauthClientV1AuthReauthenticate = <TError = ErrorType<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, TError,{client: 'app' | 'browser';data: BodyType<ReauthenticateBody>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
        TError,
        {client: 'app' | 'browser';data: BodyType<ReauthenticateBody>},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthReauthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    